; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\mbrtu.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\mbrtu.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\fonts -I..\..\User\images -I..\..\User\uIP\uip -I..\..\User\uIP\http -I..\..\User\uIP\dm9000 -I..\..\User\FatFS\src -I..\..\User\usb_mass -I..\..\User\CH376\inc -I..\..\User\FreeRTOS\Source\include -I..\..\User\FreeRTOS\Source\portable\MemMang -I..\..\User\FreeRTOS\Source\portable\RVDS\ARM_CM3 -I..\..\User\FreeModbus-V1.5\include -I..\..\User\FreeModbus-V1.5\STM32F103-PORT -I..\..\User\FreeModbus-V1.5\BARE\port -I..\..\User\FreeModbus-V1.5\rtu -IE:\woosiyuan\smarthome\stm32f10x\STM32F103_modbus_rtu\Project\MDK-ARM(uV4)\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=515 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\mbrtu.crf ..\..\User\FreeModbus-V1.5\rtu\mbrtu.c]
                          THUMB

                          AREA ||i.__set_PRIMASK||, CODE, READONLY, ALIGN=1

                  __set_PRIMASK PROC
;;;179     */
;;;180    __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
000000  f3808810          MSR      PRIMASK,r0
;;;181    {
;;;182      register uint32_t __regPriMask         __ASM("primask");
;;;183      __regPriMask = (priMask);
;;;184    }
000004  4770              BX       lr
;;;185    
                          ENDP


                          AREA ||i.eMBRTUInit||, CODE, READONLY, ALIGN=2

                  eMBRTUInit PROC
;;;80     eMBErrorCode
;;;81     eMBRTUInit( UCHAR ucSlaveAddress, UCHAR ucPort, ULONG ulBaudRate, eMBParity eParity )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;82     {
000004  4681              MOV      r9,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
00000a  461f              MOV      r7,r3
;;;83         eMBErrorCode    eStatus = MB_ENOERR;
00000c  f04f0800          MOV      r8,#0
;;;84         ULONG           usTimerT35_50us;
;;;85     
;;;86         ( void )ucSlaveAddress;
;;;87         ENTER_CRITICAL_SECTION(  );
000010  2001              MOVS     r0,#1
000012  f7fffffe          BL       __set_PRIMASK
;;;88     
;;;89         /* Modbus RTU uses 8 Databits. */
;;;90         if( xMBPortSerialInit( ucPort, ulBaudRate, 8, eParity ) != TRUE )
000016  463b              MOV      r3,r7
000018  2208              MOVS     r2,#8
00001a  4621              MOV      r1,r4
00001c  4630              MOV      r0,r6
00001e  f7fffffe          BL       xMBPortSerialInit
000022  2801              CMP      r0,#1
000024  d002              BEQ      |L2.44|
;;;91         {
;;;92             eStatus = MB_EPORTERR;
000026  f04f0803          MOV      r8,#3
00002a  e00f              B        |L2.76|
                  |L2.44|
;;;93         }
;;;94         else
;;;95         {
;;;96             /* If baudrate > 19200 then we should use the fixed timer values
;;;97              * t35 = 1750us. Otherwise t35 must be 3.5 times the character time.
;;;98              */
;;;99             if( ulBaudRate > 19200 )
00002c  f5b44f96          CMP      r4,#0x4b00
000030  d901              BLS      |L2.54|
;;;100            {
;;;101                usTimerT35_50us = 35;       /* 1800us. */
000032  2523              MOVS     r5,#0x23
000034  e003              B        |L2.62|
                  |L2.54|
;;;102            }
;;;103            else
;;;104            {
;;;105                /* The timer reload value for a character is given by:
;;;106                 *
;;;107                 * ChTimeValue = Ticks_per_1s / ( Baudrate / 11 )
;;;108                 *             = 11 * Ticks_per_1s / Baudrate
;;;109                 *             = 220000 / Baudrate
;;;110                 * The reload for t3.5 is 1.5 times this value and similary
;;;111                 * for t3.5.
;;;112                 */
;;;113                usTimerT35_50us = ( 7UL * 220000UL ) / ( 2UL * ulBaudRate );
000036  0060              LSLS     r0,r4,#1
000038  4907              LDR      r1,|L2.88|
00003a  fbb1f5f0          UDIV     r5,r1,r0
                  |L2.62|
;;;114            }
;;;115            if( xMBPortTimersInit( ( USHORT ) usTimerT35_50us ) != TRUE )
00003e  b2a8              UXTH     r0,r5
000040  f7fffffe          BL       xMBPortTimersInit
000044  2801              CMP      r0,#1
000046  d001              BEQ      |L2.76|
;;;116            {
;;;117                eStatus = MB_EPORTERR;
000048  f04f0803          MOV      r8,#3
                  |L2.76|
;;;118            }
;;;119        }
;;;120        EXIT_CRITICAL_SECTION(  );
00004c  2000              MOVS     r0,#0
00004e  f7fffffe          BL       __set_PRIMASK
;;;121    
;;;122        return eStatus;
000052  4640              MOV      r0,r8
;;;123    }
000054  e8bd87f0          POP      {r4-r10,pc}
;;;124    
                          ENDP

                  |L2.88|
                          DCD      0x00177fa0

                          AREA ||i.eMBRTUReceive||, CODE, READONLY, ALIGN=2

                  eMBRTUReceive PROC
;;;150    eMBErrorCode
;;;151    eMBRTUReceive( UCHAR * pucRcvAddress, UCHAR ** pucFrame, USHORT * pusLength )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;152    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;153        BOOL            xFrameReceived = FALSE;
00000a  f04f0800          MOV      r8,#0
;;;154        eMBErrorCode    eStatus = MB_ENOERR;
00000e  2700              MOVS     r7,#0
;;;155    
;;;156        ENTER_CRITICAL_SECTION(  );
000010  2001              MOVS     r0,#1
000012  f7fffffe          BL       __set_PRIMASK
;;;157        assert( usRcvBufferPos < MB_SER_PDU_SIZE_MAX );
;;;158    
;;;159        /* Length and CRC check */
;;;160        if( ( usRcvBufferPos >= MB_SER_PDU_SIZE_MIN )
000016  480f              LDR      r0,|L3.84|
000018  8800              LDRH     r0,[r0,#0]  ; usRcvBufferPos
00001a  2804              CMP      r0,#4
00001c  db12              BLT      |L3.68|
;;;161            && ( usMBCRC16( ( UCHAR * ) ucRTUBuf, usRcvBufferPos ) == 0 ) )
00001e  480d              LDR      r0,|L3.84|
000020  8801              LDRH     r1,[r0,#0]  ; usRcvBufferPos
000022  480d              LDR      r0,|L3.88|
000024  f7fffffe          BL       usMBCRC16
000028  b960              CBNZ     r0,|L3.68|
;;;162        {
;;;163            /* Save the address field. All frames are passed to the upper layed
;;;164             * and the decision if a frame is used is done there.
;;;165             */
;;;166            *pucRcvAddress = ucRTUBuf[MB_SER_PDU_ADDR_OFF];
00002a  480b              LDR      r0,|L3.88|
00002c  7800              LDRB     r0,[r0,#0]  ; ucRTUBuf
00002e  7020              STRB     r0,[r4,#0]
;;;167    
;;;168            /* Total length of Modbus-PDU is Modbus-Serial-Line-PDU minus
;;;169             * size of address field and CRC checksum.
;;;170             */
;;;171            *pusLength = ( USHORT )( usRcvBufferPos - MB_SER_PDU_PDU_OFF - MB_SER_PDU_SIZE_CRC );
000030  4808              LDR      r0,|L3.84|
000032  8800              LDRH     r0,[r0,#0]  ; usRcvBufferPos
000034  1ec0              SUBS     r0,r0,#3
000036  8030              STRH     r0,[r6,#0]
;;;172    
;;;173            /* Return the start of the Modbus PDU to the caller. */
;;;174            *pucFrame = ( UCHAR * ) & ucRTUBuf[MB_SER_PDU_PDU_OFF];
000038  4807              LDR      r0,|L3.88|
00003a  1c40              ADDS     r0,r0,#1
00003c  6028              STR      r0,[r5,#0]
;;;175            xFrameReceived = TRUE;
00003e  f04f0801          MOV      r8,#1
000042  e000              B        |L3.70|
                  |L3.68|
;;;176        }
;;;177        else
;;;178        {
;;;179            eStatus = MB_EIO;
000044  2705              MOVS     r7,#5
                  |L3.70|
;;;180        }
;;;181    
;;;182        EXIT_CRITICAL_SECTION(  );
000046  2000              MOVS     r0,#0
000048  f7fffffe          BL       __set_PRIMASK
;;;183        return eStatus;
00004c  4638              MOV      r0,r7
;;;184    }
00004e  e8bd81f0          POP      {r4-r8,pc}
;;;185    
                          ENDP

000052  0000              DCW      0x0000
                  |L3.84|
                          DCD      usRcvBufferPos
                  |L3.88|
                          DCD      ucRTUBuf

                          AREA ||i.eMBRTUSend||, CODE, READONLY, ALIGN=2

                  eMBRTUSend PROC
;;;186    eMBErrorCode
;;;187    eMBRTUSend( UCHAR ucSlaveAddress, const UCHAR * pucFrame, USHORT usLength )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;188    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;189        eMBErrorCode    eStatus = MB_ENOERR;
00000a  f04f0800          MOV      r8,#0
;;;190        USHORT          usCRC16;
;;;191    
;;;192        ENTER_CRITICAL_SECTION(  );
00000e  2001              MOVS     r0,#1
000010  f7fffffe          BL       __set_PRIMASK
;;;193    
;;;194        /* Check if the receiver is still in idle state. If not we where to
;;;195         * slow with processing the received frame and the master sent another
;;;196         * frame on the network. We have to abort sending the frame.
;;;197         */
;;;198        if( eRcvState == STATE_RX_IDLE )
000014  481a              LDR      r0,|L4.128|
000016  7800              LDRB     r0,[r0,#0]  ; eRcvState
000018  2801              CMP      r0,#1
00001a  d129              BNE      |L4.112|
;;;199        {
;;;200            /* First byte before the Modbus-PDU is the slave address. */
;;;201            pucSndBufferCur = ( UCHAR * ) pucFrame - 1;
00001c  1e70              SUBS     r0,r6,#1
00001e  4919              LDR      r1,|L4.132|
000020  6008              STR      r0,[r1,#0]  ; pucSndBufferCur
;;;202            usSndBufferCount = 1;
000022  2001              MOVS     r0,#1
000024  4918              LDR      r1,|L4.136|
000026  8008              STRH     r0,[r1,#0]
;;;203    
;;;204            /* Now copy the Modbus-PDU into the Modbus-Serial-Line-PDU. */
;;;205            pucSndBufferCur[MB_SER_PDU_ADDR_OFF] = ucSlaveAddress;
000028  4816              LDR      r0,|L4.132|
00002a  6800              LDR      r0,[r0,#0]  ; pucSndBufferCur
00002c  7005              STRB     r5,[r0,#0]
;;;206            usSndBufferCount += usLength;
00002e  4608              MOV      r0,r1
000030  8800              LDRH     r0,[r0,#0]  ; usSndBufferCount
000032  4438              ADD      r0,r0,r7
000034  8008              STRH     r0,[r1,#0]
;;;207    
;;;208            /* Calculate CRC16 checksum for Modbus-Serial-Line-PDU. */
;;;209            usCRC16 = usMBCRC16( ( UCHAR * ) pucSndBufferCur, usSndBufferCount );
000036  4608              MOV      r0,r1
000038  8801              LDRH     r1,[r0,#0]  ; usSndBufferCount
00003a  4812              LDR      r0,|L4.132|
00003c  6800              LDR      r0,[r0,#0]  ; pucSndBufferCur
00003e  f7fffffe          BL       usMBCRC16
000042  4604              MOV      r4,r0
;;;210            ucRTUBuf[usSndBufferCount++] = ( UCHAR )( usCRC16 & 0xFF );
000044  4910              LDR      r1,|L4.136|
000046  8808              LDRH     r0,[r1,#0]  ; usSndBufferCount
000048  1c41              ADDS     r1,r0,#1
00004a  4b0f              LDR      r3,|L4.136|
00004c  8019              STRH     r1,[r3,#0]
00004e  490f              LDR      r1,|L4.140|
000050  540c              STRB     r4,[r1,r0]
;;;211            ucRTUBuf[usSndBufferCount++] = ( UCHAR )( usCRC16 >> 8 );
000052  1222              ASRS     r2,r4,#8
000054  4619              MOV      r1,r3
000056  8808              LDRH     r0,[r1,#0]  ; usSndBufferCount
000058  1c41              ADDS     r1,r0,#1
00005a  8019              STRH     r1,[r3,#0]
00005c  490b              LDR      r1,|L4.140|
00005e  540a              STRB     r2,[r1,r0]
;;;212    
;;;213            /* Activate the transmitter. */
;;;214            eSndState = STATE_TX_XMIT;
000060  2001              MOVS     r0,#1
000062  490b              LDR      r1,|L4.144|
000064  7008              STRB     r0,[r1,#0]
;;;215            vMBPortSerialEnable( FALSE, TRUE );
000066  2101              MOVS     r1,#1
000068  2000              MOVS     r0,#0
00006a  f7fffffe          BL       vMBPortSerialEnable
00006e  e001              B        |L4.116|
                  |L4.112|
;;;216        }
;;;217        else
;;;218        {
;;;219            eStatus = MB_EIO;
000070  f04f0805          MOV      r8,#5
                  |L4.116|
;;;220        }
;;;221        EXIT_CRITICAL_SECTION(  );
000074  2000              MOVS     r0,#0
000076  f7fffffe          BL       __set_PRIMASK
;;;222        return eStatus;
00007a  4640              MOV      r0,r8
;;;223    }
00007c  e8bd81f0          POP      {r4-r8,pc}
;;;224    
                          ENDP

                  |L4.128|
                          DCD      eRcvState
                  |L4.132|
                          DCD      pucSndBufferCur
                  |L4.136|
                          DCD      usSndBufferCount
                  |L4.140|
                          DCD      ucRTUBuf
                  |L4.144|
                          DCD      eSndState

                          AREA ||i.eMBRTUStart||, CODE, READONLY, ALIGN=2

                  eMBRTUStart PROC
;;;125    void
;;;126    eMBRTUStart( void )
000000  b510              PUSH     {r4,lr}
;;;127    {
;;;128        ENTER_CRITICAL_SECTION(  );
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       __set_PRIMASK
;;;129        /* Initially the receiver is in the state STATE_RX_INIT. we start
;;;130         * the timer and if no character is received within t3.5 we change
;;;131         * to STATE_RX_IDLE. This makes sure that we delay startup of the
;;;132         * modbus protocol stack until the bus is free.
;;;133         */
;;;134        eRcvState = STATE_RX_INIT;
000008  2000              MOVS     r0,#0
00000a  4906              LDR      r1,|L5.36|
00000c  7008              STRB     r0,[r1,#0]
;;;135        vMBPortSerialEnable( TRUE, FALSE );
00000e  2100              MOVS     r1,#0
000010  2001              MOVS     r0,#1
000012  f7fffffe          BL       vMBPortSerialEnable
;;;136        vMBPortTimersEnable(  );
000016  f7fffffe          BL       vMBPortTimersEnable
;;;137    
;;;138        EXIT_CRITICAL_SECTION(  );
00001a  2000              MOVS     r0,#0
00001c  f7fffffe          BL       __set_PRIMASK
;;;139    }
000020  bd10              POP      {r4,pc}
;;;140    
                          ENDP

000022  0000              DCW      0x0000
                  |L5.36|
                          DCD      eRcvState

                          AREA ||i.eMBRTUStop||, CODE, READONLY, ALIGN=1

                  eMBRTUStop PROC
;;;141    void
;;;142    eMBRTUStop( void )
000000  b510              PUSH     {r4,lr}
;;;143    {
;;;144        ENTER_CRITICAL_SECTION(  );
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       __set_PRIMASK
;;;145        vMBPortSerialEnable( FALSE, FALSE );
000008  2100              MOVS     r1,#0
00000a  4608              MOV      r0,r1
00000c  f7fffffe          BL       vMBPortSerialEnable
;;;146        vMBPortTimersDisable(  );
000010  f7fffffe          BL       vMBPortTimersDisable
;;;147        EXIT_CRITICAL_SECTION(  );
000014  2000              MOVS     r0,#0
000016  f7fffffe          BL       __set_PRIMASK
;;;148    }
00001a  bd10              POP      {r4,pc}
;;;149    
                          ENDP


                          AREA ||i.xMBRTUReceiveFSM||, CODE, READONLY, ALIGN=2

                  xMBRTUReceiveFSM PROC
;;;225    BOOL
;;;226    xMBRTUReceiveFSM( void )
000000  b538              PUSH     {r3-r5,lr}
;;;227    {
;;;228        BOOL            xTaskNeedSwitch = FALSE;
000002  2400              MOVS     r4,#0
;;;229        UCHAR           ucByte;
;;;230    
;;;231        assert( eSndState == STATE_TX_IDLE );
;;;232    
;;;233        /* Always read the character. */
;;;234        ( void )xMBPortSerialGetByte( ( CHAR * ) & ucByte );
000004  4668              MOV      r0,sp
000006  f7fffffe          BL       xMBPortSerialGetByte
;;;235    
;;;236        switch ( eRcvState )
00000a  481c              LDR      r0,|L7.124|
00000c  7800              LDRB     r0,[r0,#0]  ; eRcvState
00000e  b130              CBZ      r0,|L7.30|
000010  2801              CMP      r0,#1
000012  d00a              BEQ      |L7.42|
000014  2802              CMP      r0,#2
000016  d019              BEQ      |L7.76|
000018  2803              CMP      r0,#3
00001a  d12b              BNE      |L7.116|
00001c  e002              B        |L7.36|
                  |L7.30|
;;;237        {
;;;238            /* If we have received a character in the init state we have to
;;;239             * wait until the frame is finished.
;;;240             */
;;;241        case STATE_RX_INIT:
;;;242            vMBPortTimersEnable(  );
00001e  f7fffffe          BL       vMBPortTimersEnable
;;;243            break;
000022  e027              B        |L7.116|
                  |L7.36|
;;;244    
;;;245            /* In the error state we wait until all characters in the
;;;246             * damaged frame are transmitted.
;;;247             */
;;;248        case STATE_RX_ERROR:
;;;249            vMBPortTimersEnable(  );
000024  f7fffffe          BL       vMBPortTimersEnable
;;;250            break;
000028  e024              B        |L7.116|
                  |L7.42|
;;;251    
;;;252            /* In the idle state we wait for a new character. If a character
;;;253             * is received the t1.5 and t3.5 timers are started and the
;;;254             * receiver is in the state STATE_RX_RECEIVCE.
;;;255             */
;;;256        case STATE_RX_IDLE:
;;;257            usRcvBufferPos = 0;
00002a  2000              MOVS     r0,#0
00002c  4914              LDR      r1,|L7.128|
00002e  8008              STRH     r0,[r1,#0]
;;;258            ucRTUBuf[usRcvBufferPos++] = ucByte;
000030  f89d2000          LDRB     r2,[sp,#0]
000034  8808              LDRH     r0,[r1,#0]  ; usRcvBufferPos
000036  1c41              ADDS     r1,r0,#1
000038  4b11              LDR      r3,|L7.128|
00003a  8019              STRH     r1,[r3,#0]
00003c  4911              LDR      r1,|L7.132|
00003e  540a              STRB     r2,[r1,r0]
;;;259            eRcvState = STATE_RX_RCV;
000040  2002              MOVS     r0,#2
000042  490e              LDR      r1,|L7.124|
000044  7008              STRB     r0,[r1,#0]
;;;260    
;;;261            /* Enable t3.5 timers. */
;;;262            vMBPortTimersEnable(  );
000046  f7fffffe          BL       vMBPortTimersEnable
;;;263            break;
00004a  e013              B        |L7.116|
                  |L7.76|
;;;264    
;;;265            /* We are currently receiving a frame. Reset the timer after
;;;266             * every character received. If more than the maximum possible
;;;267             * number of bytes in a modbus frame is received the frame is
;;;268             * ignored.
;;;269             */
;;;270        case STATE_RX_RCV:
;;;271            if( usRcvBufferPos < MB_SER_PDU_SIZE_MAX )
00004c  480c              LDR      r0,|L7.128|
00004e  8800              LDRH     r0,[r0,#0]  ; usRcvBufferPos
000050  28ff              CMP      r0,#0xff
000052  dc09              BGT      |L7.104|
;;;272            {
;;;273                ucRTUBuf[usRcvBufferPos++] = ucByte;
000054  f89d2000          LDRB     r2,[sp,#0]
000058  4909              LDR      r1,|L7.128|
00005a  8808              LDRH     r0,[r1,#0]  ; usRcvBufferPos
00005c  1c41              ADDS     r1,r0,#1
00005e  4b08              LDR      r3,|L7.128|
000060  8019              STRH     r1,[r3,#0]
000062  4908              LDR      r1,|L7.132|
000064  540a              STRB     r2,[r1,r0]
000066  e002              B        |L7.110|
                  |L7.104|
;;;274            }
;;;275            else
;;;276            {
;;;277                eRcvState = STATE_RX_ERROR;
000068  2003              MOVS     r0,#3
00006a  4904              LDR      r1,|L7.124|
00006c  7008              STRB     r0,[r1,#0]
                  |L7.110|
;;;278            }
;;;279            vMBPortTimersEnable(  );
00006e  f7fffffe          BL       vMBPortTimersEnable
;;;280            break;
000072  bf00              NOP      
                  |L7.116|
000074  bf00              NOP                            ;243
;;;281        }
;;;282        return xTaskNeedSwitch;
000076  4620              MOV      r0,r4
;;;283    }
000078  bd38              POP      {r3-r5,pc}
;;;284    
                          ENDP

00007a  0000              DCW      0x0000
                  |L7.124|
                          DCD      eRcvState
                  |L7.128|
                          DCD      usRcvBufferPos
                  |L7.132|
                          DCD      ucRTUBuf

                          AREA ||i.xMBRTUTimerT35Expired||, CODE, READONLY, ALIGN=2

                  xMBRTUTimerT35Expired PROC
;;;323    BOOL
;;;324    xMBRTUTimerT35Expired( void )
000000  b510              PUSH     {r4,lr}
;;;325    {
;;;326        BOOL            xNeedPoll = FALSE;
000002  2400              MOVS     r4,#0
;;;327    
;;;328        switch ( eRcvState )
000004  480d              LDR      r0,|L8.60|
000006  7800              LDRB     r0,[r0,#0]  ; eRcvState
000008  b120              CBZ      r0,|L8.20|
00000a  2802              CMP      r0,#2
00000c  d007              BEQ      |L8.30|
00000e  2803              CMP      r0,#3
000010  d10b              BNE      |L8.42|
000012  e009              B        |L8.40|
                  |L8.20|
;;;329        {
;;;330            /* Timer t35 expired. Startup phase is finished. */
;;;331        case STATE_RX_INIT:
;;;332            xNeedPoll = xMBPortEventPost( EV_READY );
000014  2000              MOVS     r0,#0
000016  f7fffffe          BL       xMBPortEventPost
00001a  4604              MOV      r4,r0
;;;333            break;
00001c  e006              B        |L8.44|
                  |L8.30|
;;;334    
;;;335            /* A frame was received and t35 expired. Notify the listener that
;;;336             * a new frame was received. */
;;;337        case STATE_RX_RCV:
;;;338            xNeedPoll = xMBPortEventPost( EV_FRAME_RECEIVED );
00001e  2001              MOVS     r0,#1
000020  f7fffffe          BL       xMBPortEventPost
000024  4604              MOV      r4,r0
;;;339            break;
000026  e001              B        |L8.44|
                  |L8.40|
;;;340    
;;;341            /* An error occured while receiving the frame. */
;;;342        case STATE_RX_ERROR:
;;;343            break;
000028  e000              B        |L8.44|
                  |L8.42|
00002a  bf00              NOP                            ;328
                  |L8.44|
00002c  bf00              NOP                            ;333
;;;344    
;;;345            /* Function called in an illegal state. */
;;;346        default:
;;;347            assert( ( eRcvState == STATE_RX_INIT ) ||
;;;348                    ( eRcvState == STATE_RX_RCV ) || ( eRcvState == STATE_RX_ERROR ) );
;;;349        }
;;;350    
;;;351        vMBPortTimersDisable(  );
00002e  f7fffffe          BL       vMBPortTimersDisable
;;;352        eRcvState = STATE_RX_IDLE;
000032  2001              MOVS     r0,#1
000034  4901              LDR      r1,|L8.60|
000036  7008              STRB     r0,[r1,#0]
;;;353    
;;;354        return xNeedPoll;
000038  4620              MOV      r0,r4
;;;355    }
00003a  bd10              POP      {r4,pc}
                          ENDP

                  |L8.60|
                          DCD      eRcvState

                          AREA ||i.xMBRTUTransmitFSM||, CODE, READONLY, ALIGN=2

                  xMBRTUTransmitFSM PROC
;;;285    BOOL
;;;286    xMBRTUTransmitFSM( void )
000000  b510              PUSH     {r4,lr}
;;;287    {
;;;288        BOOL            xNeedPoll = FALSE;
000002  2400              MOVS     r4,#0
;;;289    
;;;290        assert( eRcvState == STATE_RX_IDLE );
;;;291    
;;;292        switch ( eSndState )
000004  4816              LDR      r0,|L9.96|
000006  7800              LDRB     r0,[r0,#0]  ; eSndState
000008  b110              CBZ      r0,|L9.16|
00000a  2801              CMP      r0,#1
00000c  d124              BNE      |L9.88|
00000e  e004              B        |L9.26|
                  |L9.16|
;;;293        {
;;;294            /* We should not get a transmitter event if the transmitter is in
;;;295             * idle state.  */
;;;296        case STATE_TX_IDLE:
;;;297            /* enable receiver/disable transmitter. */
;;;298            vMBPortSerialEnable( TRUE, FALSE );
000010  2100              MOVS     r1,#0
000012  2001              MOVS     r0,#1
000014  f7fffffe          BL       vMBPortSerialEnable
;;;299            break;
000018  e01e              B        |L9.88|
                  |L9.26|
;;;300    
;;;301        case STATE_TX_XMIT:
;;;302            /* check if we are finished. */
;;;303            if( usSndBufferCount != 0 )
00001a  4812              LDR      r0,|L9.100|
00001c  8800              LDRH     r0,[r0,#0]  ; usSndBufferCount
00001e  b178              CBZ      r0,|L9.64|
;;;304            {
;;;305                xMBPortSerialPutByte( ( CHAR )*pucSndBufferCur );
000020  4911              LDR      r1,|L9.104|
000022  6809              LDR      r1,[r1,#0]  ; pucSndBufferCur
000024  7808              LDRB     r0,[r1,#0]
000026  f7fffffe          BL       xMBPortSerialPutByte
;;;306                pucSndBufferCur++;  /* next byte in sendbuffer. */
00002a  480f              LDR      r0,|L9.104|
00002c  6800              LDR      r0,[r0,#0]  ; pucSndBufferCur
00002e  1c40              ADDS     r0,r0,#1
000030  490d              LDR      r1,|L9.104|
000032  6008              STR      r0,[r1,#0]  ; pucSndBufferCur
;;;307                usSndBufferCount--;
000034  480b              LDR      r0,|L9.100|
000036  8800              LDRH     r0,[r0,#0]  ; usSndBufferCount
000038  1e40              SUBS     r0,r0,#1
00003a  490a              LDR      r1,|L9.100|
00003c  8008              STRH     r0,[r1,#0]
00003e  e00a              B        |L9.86|
                  |L9.64|
;;;308            }
;;;309            else
;;;310            {
;;;311                xNeedPoll = xMBPortEventPost( EV_FRAME_SENT );
000040  2003              MOVS     r0,#3
000042  f7fffffe          BL       xMBPortEventPost
000046  4604              MOV      r4,r0
;;;312                /* Disable transmitter. This prevents another transmit buffer
;;;313                 * empty interrupt. */
;;;314                vMBPortSerialEnable( TRUE, FALSE );
000048  2100              MOVS     r1,#0
00004a  2001              MOVS     r0,#1
00004c  f7fffffe          BL       vMBPortSerialEnable
;;;315                eSndState = STATE_TX_IDLE;
000050  2000              MOVS     r0,#0
000052  4903              LDR      r1,|L9.96|
000054  7008              STRB     r0,[r1,#0]
                  |L9.86|
;;;316            }
;;;317            break;
000056  bf00              NOP      
                  |L9.88|
000058  bf00              NOP                            ;299
;;;318        }
;;;319    
;;;320        return xNeedPoll;
00005a  4620              MOV      r0,r4
;;;321    }
00005c  bd10              POP      {r4,pc}
;;;322    
                          ENDP

00005e  0000              DCW      0x0000
                  |L9.96|
                          DCD      eSndState
                  |L9.100|
                          DCD      usSndBufferCount
                  |L9.104|
                          DCD      pucSndBufferCur

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  ucRTUBuf
                          %        256

                          AREA ||.data||, DATA, ALIGN=2

                  eSndState
000000  00                DCB      0x00
                  eRcvState
000001  000000            DCB      0x00,0x00,0x00
                  pucSndBufferCur
                          DCD      0x00000000
                  usSndBufferCount
000008  0000              DCB      0x00,0x00
                  usRcvBufferPos
00000a  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\FreeModbus-V1.5\\rtu\\mbrtu.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_mbrtu_c_0485e010____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___7_mbrtu_c_0485e010____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_mbrtu_c_0485e010____REVSH|
#line 128
|__asm___7_mbrtu_c_0485e010____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
