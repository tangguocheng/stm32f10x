; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\portserial.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\portserial.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\fonts -I..\..\User\images -I..\..\User\uIP\uip -I..\..\User\uIP\http -I..\..\User\uIP\dm9000 -I..\..\User\FatFS\src -I..\..\User\usb_mass -I..\..\User\CH376\inc -I..\..\User\FreeRTOS\Source\include -I..\..\User\FreeRTOS\Source\portable\MemMang -I..\..\User\FreeRTOS\Source\portable\RVDS\ARM_CM3 -I..\..\User\FreeModbus-V1.5\include -I..\..\User\FreeModbus-V1.5\STM32F103-PORT -I..\..\User\FreeModbus-V1.5\BARE\port -I..\..\User\FreeModbus-V1.5\rtu -IE:\woosiyuan\smarthome\stm32f10x\STM32F103_modbus_rtu\Project\MDK-ARM(uV4)\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=515 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\portserial.crf ..\..\User\FreeModbus-V1.5\BARE\port\portserial.c]
                          THUMB

                          AREA ||i.USART3_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART3_IRQHandler PROC
;;;197    
;;;198    void USART3_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;199    {
;;;200            //发生接收中断
;;;201            if(USART_GetITStatus(USART3, USART_IT_RXNE) == SET) {
000002  f2405125          MOV      r1,#0x525
000006  480d              LDR      r0,|L1.60|
000008  f7fffffe          BL       USART_GetITStatus
00000c  2801              CMP      r0,#1
00000e  d106              BNE      |L1.30|
;;;202                    prvvUARTRxISR();
000010  f7fffffe          BL       prvvUARTRxISR
;;;203                    //清除中断标志位
;;;204                    USART_ClearITPendingBit(USART3, USART_IT_RXNE);
000014  f2405125          MOV      r1,#0x525
000018  4808              LDR      r0,|L1.60|
00001a  f7fffffe          BL       USART_ClearITPendingBit
                  |L1.30|
;;;205            }
;;;206    
;;;207            //发生完成中断
;;;208            if(USART_GetITStatus(USART3, USART_IT_TXE) == SET) {
00001e  f2407127          MOV      r1,#0x727
000022  4806              LDR      r0,|L1.60|
000024  f7fffffe          BL       USART_GetITStatus
000028  2801              CMP      r0,#1
00002a  d106              BNE      |L1.58|
;;;209                    prvvUARTTxReadyISR();
00002c  f7fffffe          BL       prvvUARTTxReadyISR
;;;210                    //清除中断标志
;;;211                    USART_ClearITPendingBit(USART3, USART_IT_TXE);
000030  f2407127          MOV      r1,#0x727
000034  4801              LDR      r0,|L1.60|
000036  f7fffffe          BL       USART_ClearITPendingBit
                  |L1.58|
;;;212            }
;;;213    }
00003a  bd10              POP      {r4,pc}
;;;214    
                          ENDP

                  |L1.60|
                          DCD      0x40004800

                          AREA ||i.prvvUARTRxISR||, CODE, READONLY, ALIGN=2

                  prvvUARTRxISR PROC
;;;192     */
;;;193    static void prvvUARTRxISR( void )
000000  b510              PUSH     {r4,lr}
;;;194    {
;;;195            pxMBFrameCBByteReceived(  );
000002  4802              LDR      r0,|L2.12|
000004  6800              LDR      r0,[r0,#0]  ; pxMBFrameCBByteReceived
000006  4780              BLX      r0
;;;196    }
000008  bd10              POP      {r4,pc}
;;;197    
                          ENDP

00000a  0000              DCW      0x0000
                  |L2.12|
                          DCD      pxMBFrameCBByteReceived

                          AREA ||i.prvvUARTTxReadyISR||, CODE, READONLY, ALIGN=2

                  prvvUARTTxReadyISR PROC
;;;182     */
;;;183    static void prvvUARTTxReadyISR( void )
000000  b510              PUSH     {r4,lr}
;;;184    {
;;;185            pxMBFrameCBTransmitterEmpty(  );
000002  4802              LDR      r0,|L3.12|
000004  6800              LDR      r0,[r0,#0]  ; pxMBFrameCBTransmitterEmpty
000006  4780              BLX      r0
;;;186    }
000008  bd10              POP      {r4,pc}
;;;187    
                          ENDP

00000a  0000              DCW      0x0000
                  |L3.12|
                          DCD      pxMBFrameCBTransmitterEmpty

                          AREA ||i.vMBPortSerialEnable||, CODE, READONLY, ALIGN=2

                  vMBPortSerialEnable PROC
;;;33     void
;;;34     vMBPortSerialEnable( BOOL xRxEnable, BOOL xTxEnable )
000000  b570              PUSH     {r4-r6,lr}
;;;35     {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;36     
;;;37             /* If xRXEnable enable serial receive interrupts. If xTxENable enable
;;;38              * transmitter empty interrupts.
;;;39              */
;;;40     
;;;41             /*GXP,ADD,2016年11月9日15:13:15*/
;;;42     
;;;43             if(xRxEnable) {
000006  b155              CBZ      r5,|L4.30|
;;;44                     //使能接收和接收中断
;;;45                     USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);
000008  2201              MOVS     r2,#1
00000a  f2405125          MOV      r1,#0x525
00000e  4810              LDR      r0,|L4.80|
000010  f7fffffe          BL       USART_ITConfig
;;;46     
;;;47                     //SP485EE操作 低电平为接收模式
;;;48                     GPIO_ResetBits(GPIOE,GPIO_Pin_3);
000014  2108              MOVS     r1,#8
000016  480f              LDR      r0,|L4.84|
000018  f7fffffe          BL       GPIO_ResetBits
00001c  e009              B        |L4.50|
                  |L4.30|
;;;49             } else {
;;;50                     USART_ITConfig(USART3, USART_IT_RXNE, DISABLE);
00001e  2200              MOVS     r2,#0
000020  f2405125          MOV      r1,#0x525
000024  480a              LDR      r0,|L4.80|
000026  f7fffffe          BL       USART_ITConfig
;;;51                     //SP485EE操作 高电平为发送模式
;;;52                     GPIO_SetBits(GPIOE,GPIO_Pin_3);
00002a  2108              MOVS     r1,#8
00002c  4809              LDR      r0,|L4.84|
00002e  f7fffffe          BL       GPIO_SetBits
                  |L4.50|
;;;53             }
;;;54     
;;;55             if(xTxEnable) {
000032  b134              CBZ      r4,|L4.66|
;;;56                     //使能发送完成中断
;;;57                     USART_ITConfig(USART3, USART_IT_TXE, ENABLE);
000034  2201              MOVS     r2,#1
000036  f2407127          MOV      r1,#0x727
00003a  4805              LDR      r0,|L4.80|
00003c  f7fffffe          BL       USART_ITConfig
000040  e005              B        |L4.78|
                  |L4.66|
;;;58     
;;;59     
;;;60             } else {
;;;61                     //禁止发送完成中断
;;;62                     USART_ITConfig(USART3, USART_IT_TXE, DISABLE);
000042  2200              MOVS     r2,#0
000044  f2407127          MOV      r1,#0x727
000048  4801              LDR      r0,|L4.80|
00004a  f7fffffe          BL       USART_ITConfig
                  |L4.78|
;;;63             }
;;;64     
;;;65     }
00004e  bd70              POP      {r4-r6,pc}
;;;66     
                          ENDP

                  |L4.80|
                          DCD      0x40004800
                  |L4.84|
                          DCD      0x40011800

                          AREA ||i.xMBPortSerialGetByte||, CODE, READONLY, ALIGN=2

                  xMBPortSerialGetByte PROC
;;;163    BOOL
;;;164    xMBPortSerialGetByte( CHAR * pucByte )
000000  b510              PUSH     {r4,lr}
;;;165    {
000002  4604              MOV      r4,r0
;;;166            /* Return the byte in the UARTs receive buffer. This function is called
;;;167             * by the protocol stack after pxMBFrameCBByteReceived( ) has been called.
;;;168             */
;;;169    
;;;170            /*GXP,ADD,2016年11月9日15:13:15*/
;;;171    
;;;172            *pucByte = USART_ReceiveData(USART3);//接收数据
000004  4802              LDR      r0,|L5.16|
000006  f7fffffe          BL       USART_ReceiveData
00000a  7020              STRB     r0,[r4,#0]
;;;173    
;;;174            return TRUE;
00000c  2001              MOVS     r0,#1
;;;175    }
00000e  bd10              POP      {r4,pc}
;;;176    
                          ENDP

                  |L5.16|
                          DCD      0x40004800

                          AREA ||i.xMBPortSerialInit||, CODE, READONLY, ALIGN=2

                  xMBPortSerialInit PROC
;;;67     BOOL
;;;68     xMBPortSerialInit( UCHAR ucPORT, ULONG ulBaudRate, UCHAR ucDataBits, eMBParity eParity )
000000  b5f0              PUSH     {r4-r7,lr}
;;;69     {
000002  b087              SUB      sp,sp,#0x1c
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;70             /*GXP,ADD,2016年11月9日15:13:15*/
;;;71     
;;;72     
;;;73             GPIO_InitTypeDef  GPIO_InitStructure;
;;;74             USART_InitTypeDef USART_InitStructure;
;;;75             NVIC_InitTypeDef  NVIC_InitStructure;
;;;76     
;;;77             /*释放掉参数*/
;;;78     
;;;79             (void)ucPORT; //不修改串口
;;;80             (void)ucDataBits; //不修改数据位长度
;;;81             (void)eParity; //不修改校验格式
;;;82     
;;;83     
;;;84             /* 第1步： 开启GPIO和UART时钟 */
;;;85             RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB | RCC_APB2Periph_AFIO, ENABLE);
00000c  2101              MOVS     r1,#1
00000e  2009              MOVS     r0,#9
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;86             RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);
000014  2101              MOVS     r1,#1
000016  0488              LSLS     r0,r1,#18
000018  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;87     
;;;88             /* 第2步：将USART Tx的GPIO配置为推挽复用模式 */
;;;89             GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
00001c  f44f6080          MOV      r0,#0x400
000020  f8ad0018          STRH     r0,[sp,#0x18]
;;;90             GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
000024  2018              MOVS     r0,#0x18
000026  f88d001b          STRB     r0,[sp,#0x1b]
;;;91             GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00002a  2003              MOVS     r0,#3
00002c  f88d001a          STRB     r0,[sp,#0x1a]
;;;92             GPIO_Init(GPIOB, &GPIO_InitStructure);
000030  a906              ADD      r1,sp,#0x18
000032  4828              LDR      r0,|L6.212|
000034  f7fffffe          BL       GPIO_Init
;;;93     
;;;94             /* 第3步：将USART Rx的GPIO配置为浮空输入模式
;;;95             	由于CPU复位后，GPIO缺省都是浮空输入模式，因此下面这个步骤不是必须的
;;;96             	但是，我还是建议加上便于阅读，并且防止其它地方修改了这个口线的设置参数
;;;97             */
;;;98             GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
000038  f44f6000          MOV      r0,#0x800
00003c  f8ad0018          STRH     r0,[sp,#0x18]
;;;99             GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
000040  2004              MOVS     r0,#4
000042  f88d001b          STRB     r0,[sp,#0x1b]
;;;100            GPIO_Init(GPIOB, &GPIO_InitStructure);
000046  a906              ADD      r1,sp,#0x18
000048  4822              LDR      r0,|L6.212|
00004a  f7fffffe          BL       GPIO_Init
;;;101            /*  第3步已经做了，因此这步可以不做
;;;102            	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;103            */
;;;104            GPIO_Init(GPIOB, &GPIO_InitStructure);
00004e  a906              ADD      r1,sp,#0x18
000050  4820              LDR      r0,|L6.212|
000052  f7fffffe          BL       GPIO_Init
;;;105    
;;;106            /* 第4步： 配置串口硬件参数 */
;;;107            USART_InitStructure.USART_BaudRate = 9600;	/* 波特率 */
000056  f44f5016          MOV      r0,#0x2580
00005a  9002              STR      r0,[sp,#8]
;;;108            USART_InitStructure.USART_WordLength = USART_WordLength_8b;
00005c  2000              MOVS     r0,#0
00005e  f8ad000c          STRH     r0,[sp,#0xc]
;;;109            USART_InitStructure.USART_StopBits = USART_StopBits_1;
000062  f8ad000e          STRH     r0,[sp,#0xe]
;;;110            USART_InitStructure.USART_Parity = USART_Parity_No ;
000066  f8ad0010          STRH     r0,[sp,#0x10]
;;;111            USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
00006a  f8ad0014          STRH     r0,[sp,#0x14]
;;;112            USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
00006e  200c              MOVS     r0,#0xc
000070  f8ad0012          STRH     r0,[sp,#0x12]
;;;113            USART_Init(USART3, &USART_InitStructure);
000074  a902              ADD      r1,sp,#8
000076  4818              LDR      r0,|L6.216|
000078  f7fffffe          BL       USART_Init
;;;114    
;;;115            //设定USART1 中断优先级
;;;116            NVIC_InitStructure.NVIC_IRQChannel = USART3_IRQn;
00007c  2027              MOVS     r0,#0x27
00007e  f88d0004          STRB     r0,[sp,#4]
;;;117            NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 3;
000082  2003              MOVS     r0,#3
000084  f88d0005          STRB     r0,[sp,#5]
;;;118            NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;/*FreeRTOS采用分组4条件下这个没有用*/
000088  2000              MOVS     r0,#0
00008a  f88d0006          STRB     r0,[sp,#6]
;;;119            NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00008e  2001              MOVS     r0,#1
000090  f88d0007          STRB     r0,[sp,#7]
;;;120            NVIC_Init(&NVIC_InitStructure);
000094  a801              ADD      r0,sp,#4
000096  f7fffffe          BL       NVIC_Init
;;;121    
;;;122            //最后配置SP485EE发送和接收模式
;;;123    
;;;124            /* 配置 PE3为推挽输出，用于切换 RS485芯片的收发状态 */
;;;125            {
;;;126                    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE, ENABLE);
00009a  2101              MOVS     r1,#1
00009c  2040              MOVS     r0,#0x40
00009e  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;127    
;;;128                    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
0000a2  2010              MOVS     r0,#0x10
0000a4  f88d001b          STRB     r0,[sp,#0x1b]
;;;129                    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
0000a8  2003              MOVS     r0,#3
0000aa  f88d001a          STRB     r0,[sp,#0x1a]
;;;130                    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;
0000ae  2008              MOVS     r0,#8
0000b0  f8ad0018          STRH     r0,[sp,#0x18]
;;;131                    GPIO_Init(GPIOE, &GPIO_InitStructure);
0000b4  a906              ADD      r1,sp,#0x18
0000b6  4809              LDR      r0,|L6.220|
0000b8  f7fffffe          BL       GPIO_Init
;;;132            }
;;;133    
;;;134            /*
;;;135            	USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;136            	注意: 不要在此处打开发送中断
;;;137            	发送中断使能在SendUart()函数打开
;;;138            */
;;;139            USART_Cmd(USART3, ENABLE);		/* 使能串口 */
0000bc  2101              MOVS     r1,#1
0000be  4806              LDR      r0,|L6.216|
0000c0  f7fffffe          BL       USART_Cmd
;;;140    
;;;141            /* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;142            	如下语句解决第1个字节无法正确发送出去的问题 */
;;;143            USART_ClearFlag(USART3, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
0000c4  2140              MOVS     r1,#0x40
0000c6  4804              LDR      r0,|L6.216|
0000c8  f7fffffe          BL       USART_ClearFlag
;;;144    
;;;145            return TRUE;
0000cc  2001              MOVS     r0,#1
;;;146    
;;;147    }
0000ce  b007              ADD      sp,sp,#0x1c
0000d0  bdf0              POP      {r4-r7,pc}
;;;148    
                          ENDP

0000d2  0000              DCW      0x0000
                  |L6.212|
                          DCD      0x40010c00
                  |L6.216|
                          DCD      0x40004800
                  |L6.220|
                          DCD      0x40011800

                          AREA ||i.xMBPortSerialPutByte||, CODE, READONLY, ALIGN=2

                  xMBPortSerialPutByte PROC
;;;149    BOOL
;;;150    xMBPortSerialPutByte( CHAR ucByte )
000000  b510              PUSH     {r4,lr}
;;;151    {
000002  4604              MOV      r4,r0
;;;152            /* Put a byte in the UARTs transmit buffer. This function is called
;;;153             * by the protocol stack if pxMBFrameCBTransmitterEmpty( ) has been
;;;154             * called. */
;;;155    
;;;156            /*GXP,ADD,2016年11月9日15:13:15*/
;;;157    
;;;158            USART_SendData(USART3, ucByte);		//发送数据
000004  4621              MOV      r1,r4
000006  4802              LDR      r0,|L7.16|
000008  f7fffffe          BL       USART_SendData
;;;159    
;;;160            return TRUE;
00000c  2001              MOVS     r0,#1
;;;161    }
00000e  bd10              POP      {r4,pc}
;;;162    
                          ENDP

                  |L7.16|
                          DCD      0x40004800

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\FreeModbus-V1.5\\BARE\\port\\portserial.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_portserial_c_2d663cdd____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___12_portserial_c_2d663cdd____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_portserial_c_2d663cdd____REVSH|
#line 128
|__asm___12_portserial_c_2d663cdd____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
