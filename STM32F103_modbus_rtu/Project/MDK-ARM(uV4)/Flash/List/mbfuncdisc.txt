; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\mbfuncdisc.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\mbfuncdisc.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\fonts -I..\..\User\images -I..\..\User\uIP\uip -I..\..\User\uIP\http -I..\..\User\uIP\dm9000 -I..\..\User\FatFS\src -I..\..\User\usb_mass -I..\..\User\CH376\inc -I..\..\User\FreeRTOS\Source\include -I..\..\User\FreeRTOS\Source\portable\MemMang -I..\..\User\FreeRTOS\Source\portable\RVDS\ARM_CM3 -I..\..\User\FreeModbus-V1.5\include -I..\..\User\FreeModbus-V1.5\STM32F103-PORT -I..\..\User\FreeModbus-V1.5\BARE\port -I..\..\User\FreeModbus-V1.5\rtu -IE:\woosiyuan\smarthome\stm32f10x\STM32F103_modbus_rtu\Project\MDK-ARM(uV4)\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=515 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\mbfuncdisc.crf ..\..\User\FreeModbus-V1.5\functions\mbfuncdisc.c]
                          THUMB

                          AREA ||i.eMBFuncReadDiscreteInputs||, CODE, READONLY, ALIGN=1

                  eMBFuncReadDiscreteInputs PROC
;;;48     eMBException
;;;49     eMBFuncReadDiscreteInputs( UCHAR * pucFrame, USHORT * usLen )
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;50     {
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
;;;51         USHORT          usRegAddress;
;;;52         USHORT          usDiscreteCnt;
;;;53         UCHAR           ucNBytes;
;;;54         UCHAR          *pucFrameCur;
;;;55     
;;;56         eMBException    eStatus = MB_EX_NONE;
000008  f04f0b00          MOV      r11,#0
;;;57         eMBErrorCode    eRegStatus;
;;;58     
;;;59         if( *usLen == ( MB_PDU_FUNC_READ_SIZE + MB_PDU_SIZE_MIN ) )
00000c  8828              LDRH     r0,[r5,#0]
00000e  2805              CMP      r0,#5
000010  d147              BNE      |L1.162|
;;;60         {
;;;61             usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_READ_ADDR_OFF] << 8 );
000012  7870              LDRB     r0,[r6,#1]
000014  ea4f2900          LSL      r9,r0,#8
;;;62             usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_READ_ADDR_OFF + 1] );
000018  78b0              LDRB     r0,[r6,#2]
00001a  ea400909          ORR      r9,r0,r9
;;;63             usRegAddress++;
00001e  f1090001          ADD      r0,r9,#1
000022  fa1ff980          UXTH     r9,r0
;;;64     
;;;65             usDiscreteCnt = ( USHORT )( pucFrame[MB_PDU_FUNC_READ_DISCCNT_OFF] << 8 );
000026  78f0              LDRB     r0,[r6,#3]
000028  0204              LSLS     r4,r0,#8
;;;66             usDiscreteCnt |= ( USHORT )( pucFrame[MB_PDU_FUNC_READ_DISCCNT_OFF + 1] );
00002a  7930              LDRB     r0,[r6,#4]
00002c  4304              ORRS     r4,r4,r0
;;;67     
;;;68             /* Check if the number of registers to read is valid. If not
;;;69              * return Modbus illegal data value exception. 
;;;70              */
;;;71             if( ( usDiscreteCnt >= 1 ) &&
00002e  2c01              CMP      r4,#1
000030  db34              BLT      |L1.156|
;;;72                 ( usDiscreteCnt < MB_PDU_FUNC_READ_DISCCNT_MAX ) )
000032  f5b46ffa          CMP      r4,#0x7d0
000036  da31              BGE      |L1.156|
;;;73             {
;;;74                 /* Set the current PDU data pointer to the beginning. */
;;;75                 pucFrameCur = &pucFrame[MB_PDU_FUNC_OFF];
000038  4637              MOV      r7,r6
;;;76                 *usLen = MB_PDU_FUNC_OFF;
00003a  2000              MOVS     r0,#0
00003c  8028              STRH     r0,[r5,#0]
;;;77     
;;;78                 /* First byte contains the function code. */
;;;79                 *pucFrameCur++ = MB_FUNC_READ_DISCRETE_INPUTS;
00003e  2002              MOVS     r0,#2
000040  f8070b01          STRB     r0,[r7],#1
;;;80                 *usLen += 1;
000044  8828              LDRH     r0,[r5,#0]
000046  1c40              ADDS     r0,r0,#1
000048  8028              STRH     r0,[r5,#0]
;;;81     
;;;82                 /* Test if the quantity of coils is a multiple of 8. If not last
;;;83                  * byte is only partially field with unused coils set to zero. */
;;;84                 if( ( usDiscreteCnt & 0x0007 ) != 0 )
00004a  f0040007          AND      r0,r4,#7
00004e  b140              CBZ      r0,|L1.98|
;;;85                 {
;;;86                     ucNBytes = ( UCHAR ) ( usDiscreteCnt / 8 + 1 );
000050  4620              MOV      r0,r4
000052  17e1              ASRS     r1,r4,#31
000054  eb047151          ADD      r1,r4,r1,LSR #29
000058  10c9              ASRS     r1,r1,#3
00005a  1c49              ADDS     r1,r1,#1
00005c  f00108ff          AND      r8,r1,#0xff
000060  e005              B        |L1.110|
                  |L1.98|
;;;87                 }
;;;88                 else
;;;89                 {
;;;90                     ucNBytes = ( UCHAR ) ( usDiscreteCnt / 8 );
000062  4620              MOV      r0,r4
000064  17e1              ASRS     r1,r4,#31
000066  eb047151          ADD      r1,r4,r1,LSR #29
00006a  f3c108c7          UBFX     r8,r1,#3,#8
                  |L1.110|
;;;91                 }
;;;92                 *pucFrameCur++ = ucNBytes;
00006e  f8078b01          STRB     r8,[r7],#1
;;;93                 *usLen += 1;
000072  8828              LDRH     r0,[r5,#0]
000074  1c40              ADDS     r0,r0,#1
000076  8028              STRH     r0,[r5,#0]
;;;94     
;;;95                 eRegStatus =
000078  4622              MOV      r2,r4
00007a  4649              MOV      r1,r9
00007c  4638              MOV      r0,r7
00007e  f7fffffe          BL       eMBRegDiscreteCB
000082  4682              MOV      r10,r0
;;;96                     eMBRegDiscreteCB( pucFrameCur, usRegAddress, usDiscreteCnt );
;;;97     
;;;98                 /* If an error occured convert it into a Modbus exception. */
;;;99                 if( eRegStatus != MB_ENOERR )
000084  f1ba0f00          CMP      r10,#0
000088  d004              BEQ      |L1.148|
;;;100                {
;;;101                    eStatus = prveMBError2Exception( eRegStatus );
00008a  4650              MOV      r0,r10
00008c  f7fffffe          BL       prveMBError2Exception
000090  4683              MOV      r11,r0
000092  e008              B        |L1.166|
                  |L1.148|
;;;102                }
;;;103                else
;;;104                {
;;;105                    /* The response contains the function code, the starting address
;;;106                     * and the quantity of registers. We reuse the old values in the 
;;;107                     * buffer because they are still valid. */
;;;108                    *usLen += ucNBytes;;
000094  8828              LDRH     r0,[r5,#0]
000096  4440              ADD      r0,r0,r8
000098  8028              STRH     r0,[r5,#0]
00009a  e004              B        |L1.166|
                  |L1.156|
;;;109                }
;;;110            }
;;;111            else
;;;112            {
;;;113                eStatus = MB_EX_ILLEGAL_DATA_VALUE;
00009c  f04f0b03          MOV      r11,#3
0000a0  e001              B        |L1.166|
                  |L1.162|
;;;114            }
;;;115        }
;;;116        else
;;;117        {
;;;118            /* Can't be a valid read coil register request because the length
;;;119             * is incorrect. */
;;;120            eStatus = MB_EX_ILLEGAL_DATA_VALUE;
0000a2  f04f0b03          MOV      r11,#3
                  |L1.166|
;;;121        }
;;;122        return eStatus;
0000a6  4658              MOV      r0,r11
;;;123    }
0000a8  e8bd9ff0          POP      {r4-r12,pc}
;;;124    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\User\\FreeModbus-V1.5\\functions\\mbfuncdisc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_mbfuncdisc_c_09bb778e____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___12_mbfuncdisc_c_09bb778e____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_mbfuncdisc_c_09bb778e____REVSH|
#line 128
|__asm___12_mbfuncdisc_c_09bb778e____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
