; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\freemodbus-v1.5-port_reg.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\freemodbus-v1.5-port_reg.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\fonts -I..\..\User\images -I..\..\User\uIP\uip -I..\..\User\uIP\http -I..\..\User\uIP\dm9000 -I..\..\User\FatFS\src -I..\..\User\usb_mass -I..\..\User\CH376\inc -I..\..\User\FreeRTOS\Source\include -I..\..\User\FreeRTOS\Source\portable\MemMang -I..\..\User\FreeRTOS\Source\portable\RVDS\ARM_CM3 -I..\..\User\FreeModbus-V1.5\include -I..\..\User\FreeModbus-V1.5\STM32F103-PORT -I..\..\User\FreeModbus-V1.5\BARE\port -I..\..\User\FreeModbus-V1.5\rtu -IE:\woosiyuan\smarthome\stm32f10x\STM32F103_modbus_rtu\Project\MDK-ARM(uV4)\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=515 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\freemodbus-v1.5-port_reg.crf ..\..\User\FreeModbus-V1.5\BARE\FreeModbus-V1.5-PORT_reg.C]
                          THUMB

                          AREA ||i.eMBRegCoilsCB||, CODE, READONLY, ALIGN=1

                  eMBRegCoilsCB PROC
;;;129    eMBErrorCode
;;;130    eMBRegCoilsCB( UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNCoils,
000000  b510              PUSH     {r4,lr}
;;;131                   eMBRegisterMode eMode )
;;;132    {
000002  4604              MOV      r4,r0
;;;133        return MB_ENOREG;
000004  2001              MOVS     r0,#1
;;;134    }
000006  bd10              POP      {r4,pc}
;;;135    
                          ENDP


                          AREA ||i.eMBRegDiscreteCB||, CODE, READONLY, ALIGN=1

                  eMBRegDiscreteCB PROC
;;;136    eMBErrorCode
;;;137    eMBRegDiscreteCB( UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNDiscrete )
000000  4603              MOV      r3,r0
;;;138    {
;;;139        return MB_ENOREG;
000002  2001              MOVS     r0,#1
;;;140    }
000004  4770              BX       lr
                          ENDP


                          AREA ||i.eMBRegHoldingCB||, CODE, READONLY, ALIGN=2

                  eMBRegHoldingCB PROC
;;;87     
;;;88     eMBErrorCode eMBRegHoldingCB( UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNRegs,eMBRegisterMode eMode )
000000  b5f0              PUSH     {r4-r7,lr}
;;;89     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;90         eMBErrorCode    eStatus = MB_ENOERR;
000006  2000              MOVS     r0,#0
;;;91         int             iRegIndex;
;;;92     
;;;93         if( ( usAddress >= REG_HOLDING_START ) && ( usAddress + usNRegs <= REG_HOLDING_START + REG_HOLDING_NREGS ) )
000008  f5b55f80          CMP      r5,#0x1000
00000c  db33              BLT      |L3.118|
00000e  18ae              ADDS     r6,r5,r2
000010  f2410782          MOV      r7,#0x1082
000014  42be              CMP      r6,r7
000016  dc2e              BGT      |L3.118|
;;;94         {
;;;95             iRegIndex = ( int )( usAddress - usRegHoldingStart );
000018  4e18              LDR      r6,|L3.124|
00001a  8836              LDRH     r6,[r6,#0]  ; usRegHoldingStart
00001c  1ba9              SUBS     r1,r5,r6
;;;96             switch ( eMode )
00001e  b113              CBZ      r3,|L3.38|
000020  2b01              CMP      r3,#1
000022  d127              BNE      |L3.116|
000024  e011              B        |L3.74|
                  |L3.38|
;;;97             {
;;;98                 /* Pass current register values to the protocol stack. */
;;;99             case MB_REG_READ:
;;;100                while( usNRegs > 0 )
000026  e00d              B        |L3.68|
                  |L3.40|
;;;101                {
;;;102                    *pucRegBuffer++ = ( unsigned char )( usRegHoldingBuf[iRegIndex] >> 8 );
000028  4e15              LDR      r6,|L3.128|
00002a  f8366011          LDRH     r6,[r6,r1,LSL #1]
00002e  1236              ASRS     r6,r6,#8
000030  f8046b01          STRB     r6,[r4],#1
;;;103                    *pucRegBuffer++ = ( unsigned char )( usRegHoldingBuf[iRegIndex] & 0xFF );
000034  4e12              LDR      r6,|L3.128|
000036  f8166011          LDRB     r6,[r6,r1,LSL #1]
00003a  f8046b01          STRB     r6,[r4],#1
;;;104                    iRegIndex++;
00003e  1c49              ADDS     r1,r1,#1
;;;105                    usNRegs--;
000040  1e56              SUBS     r6,r2,#1
000042  b2b2              UXTH     r2,r6
                  |L3.68|
000044  2a00              CMP      r2,#0                 ;100
000046  dcef              BGT      |L3.40|
;;;106                }
;;;107                break;
000048  e014              B        |L3.116|
                  |L3.74|
;;;108    
;;;109                /* Update current register values with new values from the
;;;110                 * protocol stack. */
;;;111            case MB_REG_WRITE:
;;;112                while( usNRegs > 0 )
00004a  e010              B        |L3.110|
                  |L3.76|
;;;113                {
;;;114                    usRegHoldingBuf[iRegIndex] = *pucRegBuffer++ << 8;
00004c  f8147b01          LDRB     r7,[r4],#1
000050  023e              LSLS     r6,r7,#8
000052  4f0b              LDR      r7,|L3.128|
000054  f8276011          STRH     r6,[r7,r1,LSL #1]
;;;115                    usRegHoldingBuf[iRegIndex] |= *pucRegBuffer++;
000058  f8146b01          LDRB     r6,[r4],#1
00005c  f8377011          LDRH     r7,[r7,r1,LSL #1]
000060  433e              ORRS     r6,r6,r7
000062  4f07              LDR      r7,|L3.128|
000064  f8276011          STRH     r6,[r7,r1,LSL #1]
;;;116                    iRegIndex++;
000068  1c49              ADDS     r1,r1,#1
;;;117                    usNRegs--;
00006a  1e56              SUBS     r6,r2,#1
00006c  b2b2              UXTH     r2,r6
                  |L3.110|
00006e  2a00              CMP      r2,#0                 ;112
000070  dcec              BGT      |L3.76|
000072  bf00              NOP                            ;96
                  |L3.116|
000074  e000              B        |L3.120|
                  |L3.118|
;;;118                }
;;;119            }
;;;120        }
;;;121        else
;;;122        {
;;;123            eStatus = MB_ENOREG;
000076  2001              MOVS     r0,#1
                  |L3.120|
;;;124        }
;;;125        return eStatus;
;;;126    }
000078  bdf0              POP      {r4-r7,pc}
;;;127    
                          ENDP

00007a  0000              DCW      0x0000
                  |L3.124|
                          DCD      usRegHoldingStart
                  |L3.128|
                          DCD      usRegHoldingBuf

                          AREA ||i.eMBRegInputCB||, CODE, READONLY, ALIGN=2

                  eMBRegInputCB PROC
;;;47     //* pucRegBuffer 为要添加到协议中的数据，usAddress 为寄存器地址，usNRegs 为要读取寄存器的个数。
;;;48     eMBErrorCode eMBRegInputCB( UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNRegs )
000000  b530              PUSH     {r4,r5,lr}
;;;49     {
000002  4603              MOV      r3,r0
;;;50         eMBErrorCode    eStatus = MB_ENOERR;/*!< no error. */
000004  2000              MOVS     r0,#0
;;;51         int             iRegIndex;
;;;52     	
;;;53     		//寄存器地址首先要大于等于 1000，地址+寄存器的个数 要小于 1004
;;;54     
;;;55         if( ( usAddress >= REG_INPUT_START ) && ( usAddress + usNRegs <= REG_INPUT_START + REG_INPUT_NREGS ) )
000006  f5b17f7a          CMP      r1,#0x3e8
00000a  db18              BLT      |L4.62|
00000c  188d              ADDS     r5,r1,r2
00000e  f5b57f7b          CMP      r5,#0x3ec
000012  dc14              BGT      |L4.62|
;;;56         {
;;;57             iRegIndex = ( int )( usAddress - usRegInputStart );//计算 索引
000014  4d0b              LDR      r5,|L4.68|
000016  882d              LDRH     r5,[r5,#0]  ; usRegInputStart
000018  1b4c              SUBS     r4,r1,r5
;;;58     			
;;;59             while( usNRegs > 0 )//当要读取寄存器的个数大于0
00001a  e00d              B        |L4.56|
                  |L4.28|
;;;60             {
;;;61     					
;;;62     					//因为寄存器是16位 为一个单位，因此数据 要分开处理！
;;;63     					
;;;64                 *pucRegBuffer++ = ( unsigned char )( usRegInputBuf[iRegIndex] >> 8 );
00001c  4d0a              LDR      r5,|L4.72|
00001e  f8355014          LDRH     r5,[r5,r4,LSL #1]
000022  122d              ASRS     r5,r5,#8
000024  f8035b01          STRB     r5,[r3],#1
;;;65     					
;;;66                 *pucRegBuffer++ = ( unsigned char )( usRegInputBuf[iRegIndex] & 0xFF );
000028  4d07              LDR      r5,|L4.72|
00002a  f8155014          LDRB     r5,[r5,r4,LSL #1]
00002e  f8035b01          STRB     r5,[r3],#1
;;;67     					
;;;68                 iRegIndex++;//索引++
000032  1c64              ADDS     r4,r4,#1
;;;69     					
;;;70                 usNRegs--;//读取寄存器的个数--
000034  1e55              SUBS     r5,r2,#1
000036  b2aa              UXTH     r2,r5
                  |L4.56|
000038  2a00              CMP      r2,#0                 ;59
00003a  dcef              BGT      |L4.28|
00003c  e000              B        |L4.64|
                  |L4.62|
;;;71     					
;;;72             }
;;;73         }
;;;74         else
;;;75         {
;;;76             eStatus = MB_ENOREG;/*!< illegal register address. */
00003e  2001              MOVS     r0,#1
                  |L4.64|
;;;77         }
;;;78     
;;;79         return eStatus;
;;;80     }
000040  bd30              POP      {r4,r5,pc}
;;;81     
                          ENDP

000042  0000              DCW      0x0000
                  |L4.68|
                          DCD      usRegInputStart
                  |L4.72|
                          DCD      usRegInputBuf

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  usRegHoldingBuf
                          %        260

                          AREA ||.data||, DATA, ALIGN=1

                  usRegInputStart
000000  03e8              DCW      0x03e8
                  usRegInputBuf
000002  0002              DCW      0x0002
000004  00030004          DCW      0x0003,0x0004
000008  0005              DCW      0x0005
                  usRegHoldingStart
00000a  1000              DCW      0x1000

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\FreeModbus-V1.5\\BARE\\FreeModbus-V1.5-PORT_reg.C"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___26_FreeModbus_V1_5_PORT_reg_C_1b5b10d4____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___26_FreeModbus_V1_5_PORT_reg_C_1b5b10d4____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___26_FreeModbus_V1_5_PORT_reg_C_1b5b10d4____REVSH|
#line 128
|__asm___26_FreeModbus_V1_5_PORT_reg_C_1b5b10d4____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
