; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\mbutils.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\mbutils.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\fonts -I..\..\User\images -I..\..\User\uIP\uip -I..\..\User\uIP\http -I..\..\User\uIP\dm9000 -I..\..\User\FatFS\src -I..\..\User\usb_mass -I..\..\User\CH376\inc -I..\..\User\FreeRTOS\Source\include -I..\..\User\FreeRTOS\Source\portable\MemMang -I..\..\User\FreeRTOS\Source\portable\RVDS\ARM_CM3 -I..\..\User\FreeModbus-V1.5\include -I..\..\User\FreeModbus-V1.5\STM32F103-PORT -I..\..\User\FreeModbus-V1.5\BARE\port -I..\..\User\FreeModbus-V1.5\rtu -IE:\woosiyuan\smarthome\stm32f10x\STM32F103_modbus_rtu\Project\MDK-ARM(uV4)\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=515 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\mbutils.crf ..\..\User\FreeModbus-V1.5\functions\mbutils.c]
                          THUMB

                          AREA ||i.prveMBError2Exception||, CODE, READONLY, ALIGN=1

                  prveMBError2Exception PROC
;;;116    eMBException
;;;117    prveMBError2Exception( eMBErrorCode eErrorCode )
000000  4601              MOV      r1,r0
;;;118    {
;;;119        eMBException    eStatus;
;;;120    
;;;121        switch ( eErrorCode )
000002  b121              CBZ      r1,|L1.14|
000004  2901              CMP      r1,#1
000006  d004              BEQ      |L1.18|
000008  2907              CMP      r1,#7
00000a  d106              BNE      |L1.26|
00000c  e003              B        |L1.22|
                  |L1.14|
;;;122        {
;;;123            case MB_ENOERR:
;;;124                eStatus = MB_EX_NONE;
00000e  2000              MOVS     r0,#0
;;;125                break;
000010  e005              B        |L1.30|
                  |L1.18|
;;;126    
;;;127            case MB_ENOREG:
;;;128                eStatus = MB_EX_ILLEGAL_DATA_ADDRESS;
000012  2002              MOVS     r0,#2
;;;129                break;
000014  e003              B        |L1.30|
                  |L1.22|
;;;130    
;;;131            case MB_ETIMEDOUT:
;;;132                eStatus = MB_EX_SLAVE_BUSY;
000016  2006              MOVS     r0,#6
;;;133                break;
000018  e001              B        |L1.30|
                  |L1.26|
;;;134    
;;;135            default:
;;;136                eStatus = MB_EX_SLAVE_DEVICE_FAILURE;
00001a  2004              MOVS     r0,#4
;;;137                break;
00001c  bf00              NOP      
                  |L1.30|
00001e  bf00              NOP                            ;125
;;;138        }
;;;139    
;;;140        return eStatus;
;;;141    }
000020  4770              BX       lr
                          ENDP


                          AREA ||i.xMBUtilGetBits||, CODE, READONLY, ALIGN=1

                  xMBUtilGetBits PROC
;;;85     UCHAR
;;;86     xMBUtilGetBits( UCHAR * ucByteBuf, USHORT usBitOffset, UCHAR ucNBits )
000000  b5f0              PUSH     {r4-r7,lr}
;;;87     {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;88         USHORT          usWordBuf;
;;;89         USHORT          usMask;
;;;90         USHORT          usByteOffset;
;;;91         USHORT          usNPreBits;
;;;92     
;;;93         /* Calculate byte offset for first byte containing the bit values starting
;;;94          * at usBitOffset. */
;;;95         usByteOffset = ( USHORT )( ( usBitOffset ) / BITS_UCHAR );
000008  08e2              LSRS     r2,r4,#3
;;;96     
;;;97         /* How many bits precede our bits to set. */
;;;98         usNPreBits = ( USHORT )( usBitOffset - usByteOffset * BITS_UCHAR );
00000a  eba400c2          SUB      r0,r4,r2,LSL #3
00000e  b287              UXTH     r7,r0
;;;99     
;;;100        /* Prepare a mask for setting the new bits. */
;;;101        usMask = ( USHORT )( ( 1 << ( USHORT ) ucNBits ) - 1 );
000010  2001              MOVS     r0,#1
000012  40a8              LSLS     r0,r0,r5
000014  1e40              SUBS     r0,r0,#1
000016  b286              UXTH     r6,r0
;;;102    
;;;103        /* copy bits into temporary storage. */
;;;104        usWordBuf = ucByteBuf[usByteOffset];
000018  5c99              LDRB     r1,[r3,r2]
;;;105        usWordBuf |= ucByteBuf[usByteOffset + 1] << BITS_UCHAR;
00001a  1c50              ADDS     r0,r2,#1
00001c  5c18              LDRB     r0,[r3,r0]
00001e  ea412100          ORR      r1,r1,r0,LSL #8
;;;106    
;;;107        /* throw away unneeded bits. */
;;;108        usWordBuf >>= usNPreBits;
000022  4139              ASRS     r1,r1,r7
;;;109    
;;;110        /* mask away bits above the requested bitfield. */
;;;111        usWordBuf &= usMask;
000024  4031              ANDS     r1,r1,r6
;;;112    
;;;113        return ( UCHAR ) usWordBuf;
000026  b2c8              UXTB     r0,r1
;;;114    }
000028  bdf0              POP      {r4-r7,pc}
;;;115    
                          ENDP


                          AREA ||i.xMBUtilSetBits||, CODE, READONLY, ALIGN=1

                  xMBUtilSetBits PROC
;;;46     void
;;;47     xMBUtilSetBits( UCHAR * ucByteBuf, USHORT usBitOffset, UCHAR ucNBits,
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;48                     UCHAR ucValue )
;;;49     {
000004  4604              MOV      r4,r0
000006  4615              MOV      r5,r2
;;;50         USHORT          usWordBuf;
;;;51         USHORT          usMask;
;;;52         USHORT          usByteOffset;
;;;53         USHORT          usNPreBits;
;;;54         USHORT          usValue = ucValue;
000008  461f              MOV      r7,r3
;;;55     
;;;56         assert( ucNBits <= 8 );
;;;57         assert( ( size_t )BITS_UCHAR == sizeof( UCHAR ) * 8 );
;;;58     
;;;59         /* Calculate byte offset for first byte containing the bit values starting
;;;60          * at usBitOffset. */
;;;61         usByteOffset = ( USHORT )( ( usBitOffset ) / BITS_UCHAR );
00000a  08c8              LSRS     r0,r1,#3
;;;62     
;;;63         /* How many bits precede our bits to set. */
;;;64         usNPreBits = ( USHORT )( usBitOffset - usByteOffset * BITS_UCHAR );
00000c  eba108c0          SUB      r8,r1,r0,LSL #3
000010  fa1ffc88          UXTH     r12,r8
;;;65     
;;;66         /* Move bit field into position over bits to set */
;;;67         usValue <<= usNPreBits;
000014  fa07f80c          LSL      r8,r7,r12
000018  fa1ff788          UXTH     r7,r8
;;;68     
;;;69         /* Prepare a mask for setting the new bits. */
;;;70         usMask = ( USHORT )( ( 1 << ( USHORT ) ucNBits ) - 1 );
00001c  f04f0801          MOV      r8,#1
000020  fa08f805          LSL      r8,r8,r5
000024  f1a80801          SUB      r8,r8,#1
000028  fa1ff688          UXTH     r6,r8
;;;71         usMask <<= usBitOffset - usByteOffset * BITS_UCHAR;
00002c  eba108c0          SUB      r8,r1,r0,LSL #3
000030  fa06f808          LSL      r8,r6,r8
000034  fa1ff688          UXTH     r6,r8
;;;72     
;;;73         /* copy bits into temporary storage. */
;;;74         usWordBuf = ucByteBuf[usByteOffset];
000038  5c22              LDRB     r2,[r4,r0]
;;;75         usWordBuf |= ucByteBuf[usByteOffset + 1] << BITS_UCHAR;
00003a  f1000801          ADD      r8,r0,#1
00003e  f8148008          LDRB     r8,[r4,r8]
000042  ea422208          ORR      r2,r2,r8,LSL #8
;;;76     
;;;77         /* Zero out bit field bits and then or value bits into them. */
;;;78         usWordBuf = ( USHORT )( ( usWordBuf & ( ~usMask ) ) | usValue );
000046  ea220806          BIC      r8,r2,r6
00004a  ea480207          ORR      r2,r8,r7
;;;79     
;;;80         /* move bits back into storage */
;;;81         ucByteBuf[usByteOffset] = ( UCHAR )( usWordBuf & 0xFF );
00004e  5422              STRB     r2,[r4,r0]
;;;82         ucByteBuf[usByteOffset + 1] = ( UCHAR )( usWordBuf >> BITS_UCHAR );
000050  ea4f2922          ASR      r9,r2,#8
000054  f1000801          ADD      r8,r0,#1
000058  f8049008          STRB     r9,[r4,r8]
;;;83     }
00005c  e8bd83f0          POP      {r4-r9,pc}
;;;84     
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\User\\FreeModbus-V1.5\\functions\\mbutils.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_mbutils_c_1da90d20____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___9_mbutils_c_1da90d20____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_mbutils_c_1da90d20____REVSH|
#line 128
|__asm___9_mbutils_c_1da90d20____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
