; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\mbfunccoils.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\mbfunccoils.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\fonts -I..\..\User\images -I..\..\User\uIP\uip -I..\..\User\uIP\http -I..\..\User\uIP\dm9000 -I..\..\User\FatFS\src -I..\..\User\usb_mass -I..\..\User\CH376\inc -I..\..\User\FreeRTOS\Source\include -I..\..\User\FreeRTOS\Source\portable\MemMang -I..\..\User\FreeRTOS\Source\portable\RVDS\ARM_CM3 -I..\..\User\FreeModbus-V1.5\include -I..\..\User\FreeModbus-V1.5\STM32F103-PORT -I..\..\User\FreeModbus-V1.5\BARE\port -I..\..\User\FreeModbus-V1.5\rtu -IE:\woosiyuan\smarthome\stm32f10x\STM32F103_modbus_rtu\Project\MDK-ARM(uV4)\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=515 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\mbfunccoils.crf ..\..\User\FreeModbus-V1.5\functions\mbfunccoils.c]
                          THUMB

                          AREA ||i.eMBFuncReadCoils||, CODE, READONLY, ALIGN=1

                  eMBFuncReadCoils PROC
;;;68     eMBException
;;;69     eMBFuncReadCoils( UCHAR * pucFrame, USHORT * usLen )
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;70     {
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
;;;71         USHORT          usRegAddress;
;;;72         USHORT          usCoilCount;
;;;73         UCHAR           ucNBytes;
;;;74         UCHAR          *pucFrameCur;
;;;75     
;;;76         eMBException    eStatus = MB_EX_NONE;
000008  f04f0b00          MOV      r11,#0
;;;77         eMBErrorCode    eRegStatus;
;;;78     
;;;79         if( *usLen == ( MB_PDU_FUNC_READ_SIZE + MB_PDU_SIZE_MIN ) )
00000c  8828              LDRH     r0,[r5,#0]
00000e  2805              CMP      r0,#5
000010  d148              BNE      |L1.164|
;;;80         {
;;;81             usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_READ_ADDR_OFF] << 8 );
000012  7870              LDRB     r0,[r6,#1]
000014  ea4f2900          LSL      r9,r0,#8
;;;82             usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_READ_ADDR_OFF + 1] );
000018  78b0              LDRB     r0,[r6,#2]
00001a  ea400909          ORR      r9,r0,r9
;;;83             usRegAddress++;
00001e  f1090001          ADD      r0,r9,#1
000022  fa1ff980          UXTH     r9,r0
;;;84     
;;;85             usCoilCount = ( USHORT )( pucFrame[MB_PDU_FUNC_READ_COILCNT_OFF] << 8 );
000026  78f0              LDRB     r0,[r6,#3]
000028  0204              LSLS     r4,r0,#8
;;;86             usCoilCount |= ( USHORT )( pucFrame[MB_PDU_FUNC_READ_COILCNT_OFF + 1] );
00002a  7930              LDRB     r0,[r6,#4]
00002c  4304              ORRS     r4,r4,r0
;;;87     
;;;88             /* Check if the number of registers to read is valid. If not
;;;89              * return Modbus illegal data value exception. 
;;;90              */
;;;91             if( ( usCoilCount >= 1 ) &&
00002e  2c01              CMP      r4,#1
000030  db35              BLT      |L1.158|
;;;92                 ( usCoilCount < MB_PDU_FUNC_READ_COILCNT_MAX ) )
000032  f5b46ffa          CMP      r4,#0x7d0
000036  da32              BGE      |L1.158|
;;;93             {
;;;94                 /* Set the current PDU data pointer to the beginning. */
;;;95                 pucFrameCur = &pucFrame[MB_PDU_FUNC_OFF];
000038  4637              MOV      r7,r6
;;;96                 *usLen = MB_PDU_FUNC_OFF;
00003a  2000              MOVS     r0,#0
00003c  8028              STRH     r0,[r5,#0]
;;;97     
;;;98                 /* First byte contains the function code. */
;;;99                 *pucFrameCur++ = MB_FUNC_READ_COILS;
00003e  2001              MOVS     r0,#1
000040  f8070b01          STRB     r0,[r7],#1
;;;100                *usLen += 1;
000044  8828              LDRH     r0,[r5,#0]
000046  1c40              ADDS     r0,r0,#1
000048  8028              STRH     r0,[r5,#0]
;;;101    
;;;102                /* Test if the quantity of coils is a multiple of 8. If not last
;;;103                 * byte is only partially field with unused coils set to zero. */
;;;104                if( ( usCoilCount & 0x0007 ) != 0 )
00004a  f0040007          AND      r0,r4,#7
00004e  b140              CBZ      r0,|L1.98|
;;;105                {
;;;106                    ucNBytes = ( UCHAR )( usCoilCount / 8 + 1 );
000050  4620              MOV      r0,r4
000052  17e1              ASRS     r1,r4,#31
000054  eb047151          ADD      r1,r4,r1,LSR #29
000058  10c9              ASRS     r1,r1,#3
00005a  1c49              ADDS     r1,r1,#1
00005c  f00108ff          AND      r8,r1,#0xff
000060  e005              B        |L1.110|
                  |L1.98|
;;;107                }
;;;108                else
;;;109                {
;;;110                    ucNBytes = ( UCHAR )( usCoilCount / 8 );
000062  4620              MOV      r0,r4
000064  17e1              ASRS     r1,r4,#31
000066  eb047151          ADD      r1,r4,r1,LSR #29
00006a  f3c108c7          UBFX     r8,r1,#3,#8
                  |L1.110|
;;;111                }
;;;112                *pucFrameCur++ = ucNBytes;
00006e  f8078b01          STRB     r8,[r7],#1
;;;113                *usLen += 1;
000072  8828              LDRH     r0,[r5,#0]
000074  1c40              ADDS     r0,r0,#1
000076  8028              STRH     r0,[r5,#0]
;;;114    
;;;115                eRegStatus =
000078  2300              MOVS     r3,#0
00007a  4622              MOV      r2,r4
00007c  4649              MOV      r1,r9
00007e  4638              MOV      r0,r7
000080  f7fffffe          BL       eMBRegCoilsCB
000084  4682              MOV      r10,r0
;;;116                    eMBRegCoilsCB( pucFrameCur, usRegAddress, usCoilCount,
;;;117                                   MB_REG_READ );
;;;118    
;;;119                /* If an error occured convert it into a Modbus exception. */
;;;120                if( eRegStatus != MB_ENOERR )
000086  f1ba0f00          CMP      r10,#0
00008a  d004              BEQ      |L1.150|
;;;121                {
;;;122                    eStatus = prveMBError2Exception( eRegStatus );
00008c  4650              MOV      r0,r10
00008e  f7fffffe          BL       prveMBError2Exception
000092  4683              MOV      r11,r0
000094  e008              B        |L1.168|
                  |L1.150|
;;;123                }
;;;124                else
;;;125                {
;;;126                    /* The response contains the function code, the starting address
;;;127                     * and the quantity of registers. We reuse the old values in the 
;;;128                     * buffer because they are still valid. */
;;;129                    *usLen += ucNBytes;;
000096  8828              LDRH     r0,[r5,#0]
000098  4440              ADD      r0,r0,r8
00009a  8028              STRH     r0,[r5,#0]
00009c  e004              B        |L1.168|
                  |L1.158|
;;;130                }
;;;131            }
;;;132            else
;;;133            {
;;;134                eStatus = MB_EX_ILLEGAL_DATA_VALUE;
00009e  f04f0b03          MOV      r11,#3
0000a2  e001              B        |L1.168|
                  |L1.164|
;;;135            }
;;;136        }
;;;137        else
;;;138        {
;;;139            /* Can't be a valid read coil register request because the length
;;;140             * is incorrect. */
;;;141            eStatus = MB_EX_ILLEGAL_DATA_VALUE;
0000a4  f04f0b03          MOV      r11,#3
                  |L1.168|
;;;142        }
;;;143        return eStatus;
0000a8  4658              MOV      r0,r11
;;;144    }
0000aa  e8bd9ff0          POP      {r4-r12,pc}
;;;145    
                          ENDP


                          AREA ||i.eMBFuncWriteCoil||, CODE, READONLY, ALIGN=1

                  eMBFuncWriteCoil PROC
;;;147    eMBException
;;;148    eMBFuncWriteCoil( UCHAR * pucFrame, USHORT * usLen )
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;149    {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
;;;150        USHORT          usRegAddress;
;;;151        UCHAR           ucBuf[2];
;;;152    
;;;153        eMBException    eStatus = MB_EX_NONE;
000008  f04f0800          MOV      r8,#0
;;;154        eMBErrorCode    eRegStatus;
;;;155    
;;;156        if( *usLen == ( MB_PDU_FUNC_WRITE_SIZE + MB_PDU_SIZE_MIN ) )
00000c  8838              LDRH     r0,[r7,#0]
00000e  2805              CMP      r0,#5
000010  d129              BNE      |L2.102|
;;;157        {
;;;158            usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_ADDR_OFF] << 8 );
000012  7860              LDRB     r0,[r4,#1]
000014  0205              LSLS     r5,r0,#8
;;;159            usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_ADDR_OFF + 1] );
000016  78a0              LDRB     r0,[r4,#2]
000018  4305              ORRS     r5,r5,r0
;;;160            usRegAddress++;
00001a  1c68              ADDS     r0,r5,#1
00001c  b285              UXTH     r5,r0
;;;161    
;;;162            if( ( pucFrame[MB_PDU_FUNC_WRITE_VALUE_OFF + 1] == 0x00 ) &&
00001e  7920              LDRB     r0,[r4,#4]
000020  b9f0              CBNZ     r0,|L2.96|
;;;163                ( ( pucFrame[MB_PDU_FUNC_WRITE_VALUE_OFF] == 0xFF ) ||
000022  78e0              LDRB     r0,[r4,#3]
000024  28ff              CMP      r0,#0xff
000026  d001              BEQ      |L2.44|
;;;164                  ( pucFrame[MB_PDU_FUNC_WRITE_VALUE_OFF] == 0x00 ) ) )
000028  78e0              LDRB     r0,[r4,#3]
00002a  b9c8              CBNZ     r0,|L2.96|
                  |L2.44|
;;;165            {
;;;166                ucBuf[1] = 0;
00002c  2000              MOVS     r0,#0
00002e  f88d0001          STRB     r0,[sp,#1]
;;;167                if( pucFrame[MB_PDU_FUNC_WRITE_VALUE_OFF] == 0xFF )
000032  78e0              LDRB     r0,[r4,#3]
000034  28ff              CMP      r0,#0xff
000036  d103              BNE      |L2.64|
;;;168                {
;;;169                    ucBuf[0] = 1;
000038  2001              MOVS     r0,#1
00003a  f88d0000          STRB     r0,[sp,#0]
00003e  e002              B        |L2.70|
                  |L2.64|
;;;170                }
;;;171                else
;;;172                {
;;;173                    ucBuf[0] = 0;
000040  2000              MOVS     r0,#0
000042  f88d0000          STRB     r0,[sp,#0]
                  |L2.70|
;;;174                }
;;;175                eRegStatus =
000046  2301              MOVS     r3,#1
000048  461a              MOV      r2,r3
00004a  4629              MOV      r1,r5
00004c  4668              MOV      r0,sp
00004e  f7fffffe          BL       eMBRegCoilsCB
000052  4606              MOV      r6,r0
;;;176                    eMBRegCoilsCB( &ucBuf[0], usRegAddress, 1, MB_REG_WRITE );
;;;177    
;;;178                /* If an error occured convert it into a Modbus exception. */
;;;179                if( eRegStatus != MB_ENOERR )
000054  b14e              CBZ      r6,|L2.106|
;;;180                {
;;;181                    eStatus = prveMBError2Exception( eRegStatus );
000056  4630              MOV      r0,r6
000058  f7fffffe          BL       prveMBError2Exception
00005c  4680              MOV      r8,r0
00005e  e004              B        |L2.106|
                  |L2.96|
;;;182                }
;;;183            }
;;;184            else
;;;185            {
;;;186                eStatus = MB_EX_ILLEGAL_DATA_VALUE;
000060  f04f0803          MOV      r8,#3
000064  e001              B        |L2.106|
                  |L2.102|
;;;187            }
;;;188        }
;;;189        else
;;;190        {
;;;191            /* Can't be a valid write coil register request because the length
;;;192             * is incorrect. */
;;;193            eStatus = MB_EX_ILLEGAL_DATA_VALUE;
000066  f04f0803          MOV      r8,#3
                  |L2.106|
;;;194        }
;;;195        return eStatus;
00006a  4640              MOV      r0,r8
;;;196    }
00006c  e8bd83f8          POP      {r3-r9,pc}
;;;197    
                          ENDP


                          AREA ||i.eMBFuncWriteMultipleCoils||, CODE, READONLY, ALIGN=1

                  eMBFuncWriteMultipleCoils PROC
;;;201    eMBException
;;;202    eMBFuncWriteMultipleCoils( UCHAR * pucFrame, USHORT * usLen )
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;203    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;204        USHORT          usRegAddress;
;;;205        USHORT          usCoilCnt;
;;;206        UCHAR           ucByteCount;
;;;207        UCHAR           ucByteCountVerify;
;;;208    
;;;209        eMBException    eStatus = MB_EX_NONE;
000008  f04f0b00          MOV      r11,#0
;;;210        eMBErrorCode    eRegStatus;
;;;211    
;;;212        if( *usLen > ( MB_PDU_FUNC_WRITE_SIZE + MB_PDU_SIZE_MIN ) )
00000c  8830              LDRH     r0,[r6,#0]
00000e  2805              CMP      r0,#5
000010  dd39              BLE      |L3.134|
;;;213        {
;;;214            usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_MUL_ADDR_OFF] << 8 );
000012  7868              LDRB     r0,[r5,#1]
000014  0207              LSLS     r7,r0,#8
;;;215            usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_MUL_ADDR_OFF + 1] );
000016  78a8              LDRB     r0,[r5,#2]
000018  4307              ORRS     r7,r7,r0
;;;216            usRegAddress++;
00001a  1c78              ADDS     r0,r7,#1
00001c  b287              UXTH     r7,r0
;;;217    
;;;218            usCoilCnt = ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_MUL_COILCNT_OFF] << 8 );
00001e  78e8              LDRB     r0,[r5,#3]
000020  0204              LSLS     r4,r0,#8
;;;219            usCoilCnt |= ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_MUL_COILCNT_OFF + 1] );
000022  7928              LDRB     r0,[r5,#4]
000024  4304              ORRS     r4,r4,r0
;;;220    
;;;221            ucByteCount = pucFrame[MB_PDU_FUNC_WRITE_MUL_BYTECNT_OFF];
000026  f895a005          LDRB     r10,[r5,#5]
;;;222    
;;;223            /* Compute the number of expected bytes in the request. */
;;;224            if( ( usCoilCnt & 0x0007 ) != 0 )
00002a  f0040007          AND      r0,r4,#7
00002e  b140              CBZ      r0,|L3.66|
;;;225            {
;;;226                ucByteCountVerify = ( UCHAR )( usCoilCnt / 8 + 1 );
000030  4620              MOV      r0,r4
000032  17e1              ASRS     r1,r4,#31
000034  eb047151          ADD      r1,r4,r1,LSR #29
000038  10c9              ASRS     r1,r1,#3
00003a  1c49              ADDS     r1,r1,#1
00003c  f00108ff          AND      r8,r1,#0xff
000040  e005              B        |L3.78|
                  |L3.66|
;;;227            }
;;;228            else
;;;229            {
;;;230                ucByteCountVerify = ( UCHAR )( usCoilCnt / 8 );
000042  4620              MOV      r0,r4
000044  17e1              ASRS     r1,r4,#31
000046  eb047151          ADD      r1,r4,r1,LSR #29
00004a  f3c108c7          UBFX     r8,r1,#3,#8
                  |L3.78|
;;;231            }
;;;232    
;;;233            if( ( usCoilCnt >= 1 ) &&
00004e  2c01              CMP      r4,#1
000050  db16              BLT      |L3.128|
;;;234                ( usCoilCnt <= MB_PDU_FUNC_WRITE_MUL_COILCNT_MAX ) &&
000052  f5b46ff6          CMP      r4,#0x7b0
000056  dc13              BGT      |L3.128|
;;;235                ( ucByteCountVerify == ucByteCount ) )
000058  45d0              CMP      r8,r10
00005a  d111              BNE      |L3.128|
;;;236            {
;;;237                eRegStatus =
00005c  2301              MOVS     r3,#1
00005e  4622              MOV      r2,r4
000060  4639              MOV      r1,r7
000062  1da8              ADDS     r0,r5,#6
000064  f7fffffe          BL       eMBRegCoilsCB
000068  4681              MOV      r9,r0
;;;238                    eMBRegCoilsCB( &pucFrame[MB_PDU_FUNC_WRITE_MUL_VALUES_OFF],
;;;239                                   usRegAddress, usCoilCnt, MB_REG_WRITE );
;;;240    
;;;241                /* If an error occured convert it into a Modbus exception. */
;;;242                if( eRegStatus != MB_ENOERR )
00006a  f1b90f00          CMP      r9,#0
00006e  d004              BEQ      |L3.122|
;;;243                {
;;;244                    eStatus = prveMBError2Exception( eRegStatus );
000070  4648              MOV      r0,r9
000072  f7fffffe          BL       prveMBError2Exception
000076  4683              MOV      r11,r0
000078  e007              B        |L3.138|
                  |L3.122|
;;;245                }
;;;246                else
;;;247                {
;;;248                    /* The response contains the function code, the starting address
;;;249                     * and the quantity of registers. We reuse the old values in the 
;;;250                     * buffer because they are still valid. */
;;;251                    *usLen = MB_PDU_FUNC_WRITE_MUL_BYTECNT_OFF;
00007a  2005              MOVS     r0,#5
00007c  8030              STRH     r0,[r6,#0]
00007e  e004              B        |L3.138|
                  |L3.128|
;;;252                }
;;;253            }
;;;254            else
;;;255            {
;;;256                eStatus = MB_EX_ILLEGAL_DATA_VALUE;
000080  f04f0b03          MOV      r11,#3
000084  e001              B        |L3.138|
                  |L3.134|
;;;257            }
;;;258        }
;;;259        else
;;;260        {
;;;261            /* Can't be a valid write coil register request because the length
;;;262             * is incorrect. */
;;;263            eStatus = MB_EX_ILLEGAL_DATA_VALUE;
000086  f04f0b03          MOV      r11,#3
                  |L3.138|
;;;264        }
;;;265        return eStatus;
00008a  4658              MOV      r0,r11
;;;266    }
00008c  e8bd9ff0          POP      {r4-r12,pc}
;;;267    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\User\\FreeModbus-V1.5\\functions\\mbfunccoils.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_mbfunccoils_c_e12d674a____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___13_mbfunccoils_c_e12d674a____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_mbfunccoils_c_e12d674a____REVSH|
#line 128
|__asm___13_mbfunccoils_c_e12d674a____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
