; generated by Component: ARM Compiler 5.05 update 2 (build 169) Tool: ArmCC [4d0f38]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\port.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\port.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\fonts -I..\..\User\images -I..\..\User\uIP\uip -I..\..\User\uIP\http -I..\..\User\uIP\dm9000 -I..\..\User\FatFS\src -I..\..\User\usb_mass -I..\..\User\CH376\inc -I..\..\User\FreeRTOS\Source\include -I..\..\User\FreeRTOS\Source\portable\MemMang -I..\..\User\FreeRTOS\Source\portable\RVDS\ARM_CM3 -I..\..\User\FreeModbus-V1.5\include -I..\..\User\FreeModbus-V1.5\STM32F103-PORT -I..\..\User\FreeModbus-V1.5\BARE\port -I..\..\User\FreeModbus-V1.5\rtu -IE:\woosiyuan\smarthome\stm32f10x\STM32F103_modbus_rtu\Project\MDK-ARM(uV4)\RTE -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.2.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=515 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\port.crf ..\..\User\FreeRTOS\Source\portable\RVDS\ARM_CM3\port.c]
                          THUMB

                          AREA ||i.prvTaskExitError||, CODE, READONLY, ALIGN=1

                  prvTaskExitError PROC
;;;234    
;;;235    static void prvTaskExitError( void )
000000  f7fffffe          BL       ulPortSetInterruptMask
;;;236    {
;;;237            /* A function that implements a task must not exit or attempt to return to
;;;238            its caller as there is nothing to return to.  If a task wants to exit it
;;;239            should instead call vTaskDelete( NULL ).
;;;240    
;;;241            Artificially force an assert() to be triggered if configASSERT() is
;;;242            defined, then stop here so application writers can catch the error. */
;;;243            configASSERT( uxCriticalNesting == ~0UL );
;;;244            portDISABLE_INTERRUPTS();
;;;245            for( ;; );
000004  bf00              NOP      
                  |L1.6|
000006  e7fe              B        |L1.6|
;;;246    }
;;;247    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.pxPortInitialiseStack||, CODE, READONLY, ALIGN=2

                  pxPortInitialiseStack PROC
;;;215     */
;;;216    StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
000000  1f00              SUBS     r0,r0,#4
;;;217    {
;;;218            /* Simulate the stack frame as it would be created by a context switch
;;;219            interrupt. */
;;;220            pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
;;;221            *pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
000002  f04f7380          MOV      r3,#0x1000000
000006  6003              STR      r3,[r0,#0]
;;;222            pxTopOfStack--;
000008  1f00              SUBS     r0,r0,#4
;;;223            *pxTopOfStack = ( StackType_t ) pxCode;	/* PC */
00000a  6001              STR      r1,[r0,#0]
;;;224            pxTopOfStack--;
00000c  1f00              SUBS     r0,r0,#4
;;;225            *pxTopOfStack = ( StackType_t ) prvTaskExitError;	/* LR */
00000e  4b03              LDR      r3,|L2.28|
000010  6003              STR      r3,[r0,#0]
;;;226    
;;;227            pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
000012  3814              SUBS     r0,r0,#0x14
;;;228            *pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
000014  6002              STR      r2,[r0,#0]
;;;229            pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
000016  3820              SUBS     r0,r0,#0x20
;;;230    
;;;231            return pxTopOfStack;
;;;232    }
000018  4770              BX       lr
;;;233    /*-----------------------------------------------------------*/
                          ENDP

00001a  0000              DCW      0x0000
                  |L2.28|
                          DCD      prvTaskExitError

                          AREA ||i.vPortEndScheduler||, CODE, READONLY, ALIGN=1

                  vPortEndScheduler PROC
;;;356    
;;;357    void vPortEndScheduler( void )
000000  4770              BX       lr
;;;358    {
;;;359            /* Not implemented in ports where there is nothing to return to.
;;;360            Artificially force an assert. */
;;;361            configASSERT( uxCriticalNesting == 1000UL );
;;;362    }
;;;363    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.vPortEnterCritical||, CODE, READONLY, ALIGN=2

                  vPortEnterCritical PROC
;;;376    
;;;377    void vPortEnterCritical( void )
000000  b510              PUSH     {r4,lr}
;;;378    {
;;;379            portDISABLE_INTERRUPTS();
000002  f7fffffe          BL       ulPortSetInterruptMask
;;;380            uxCriticalNesting++;
000006  4805              LDR      r0,|L4.28|
000008  6800              LDR      r0,[r0,#0]  ; uxCriticalNesting
00000a  1c40              ADDS     r0,r0,#1
00000c  4903              LDR      r1,|L4.28|
00000e  6008              STR      r0,[r1,#0]  ; uxCriticalNesting
;;;381            __dsb( portSY_FULL_READ_WRITE );
000010  f3bf8f4f          DSB      
;;;382            __isb( portSY_FULL_READ_WRITE );
000014  f3bf8f6f          ISB      
;;;383    
;;;384            /* This is not the interrupt safe version of the enter critical function so
;;;385            assert() if it is being called from an interrupt context.  Only API
;;;386            functions that end in "FromISR" can be used in an interrupt.  Only assert if
;;;387            the critical nesting count is 1 to protect against recursive calls if the
;;;388            assert function also uses a critical section. */
;;;389            if( uxCriticalNesting == 1 ) {
;;;390                    configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
;;;391            }
;;;392    }
000018  bd10              POP      {r4,pc}
;;;393    /*-----------------------------------------------------------*/
                          ENDP

00001a  0000              DCW      0x0000
                  |L4.28|
                          DCD      uxCriticalNesting

                          AREA ||i.vPortExitCritical||, CODE, READONLY, ALIGN=2

                  vPortExitCritical PROC
;;;394    
;;;395    void vPortExitCritical( void )
000000  b510              PUSH     {r4,lr}
;;;396    {
;;;397            configASSERT( uxCriticalNesting );
;;;398            uxCriticalNesting--;
000002  4806              LDR      r0,|L5.28|
000004  6800              LDR      r0,[r0,#0]  ; uxCriticalNesting
000006  1e40              SUBS     r0,r0,#1
000008  4904              LDR      r1,|L5.28|
00000a  6008              STR      r0,[r1,#0]  ; uxCriticalNesting
;;;399            if( uxCriticalNesting == 0 ) {
00000c  4608              MOV      r0,r1
00000e  6800              LDR      r0,[r0,#0]  ; uxCriticalNesting
000010  b910              CBNZ     r0,|L5.24|
;;;400                    portENABLE_INTERRUPTS();
000012  2000              MOVS     r0,#0
000014  f7fffffe          BL       vPortClearInterruptMask
                  |L5.24|
;;;401            }
;;;402    }
000018  bd10              POP      {r4,pc}
;;;403    /*-----------------------------------------------------------*/
                          ENDP

00001a  0000              DCW      0x0000
                  |L5.28|
                          DCD      uxCriticalNesting

                          AREA ||i.vPortSetupTimerInterrupt||, CODE, READONLY, ALIGN=2

                  vPortSetupTimerInterrupt PROC
;;;607    
;;;608    void vPortSetupTimerInterrupt( void )
000000  4803              LDR      r0,|L6.16|
;;;609    {
;;;610            /* Calculate the constants required to configure the tick interrupt. */
;;;611    #if configUSE_TICKLESS_IDLE == 1
;;;612            {
;;;613                    ulTimerCountsForOneTick = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ );
;;;614                    xMaximumPossibleSuppressedTicks = portMAX_24_BIT_NUMBER / ulTimerCountsForOneTick;
;;;615                    ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
;;;616            }
;;;617    #endif /* configUSE_TICKLESS_IDLE */
;;;618    
;;;619            /* Configure SysTick to interrupt at the requested rate. */
;;;620            portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
000002  f04f21e0          MOV      r1,#0xe000e000
000006  6148              STR      r0,[r1,#0x14]
;;;621            portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
000008  2007              MOVS     r0,#7
00000a  6108              STR      r0,[r1,#0x10]
;;;622    }
00000c  4770              BX       lr
;;;623    
                          ENDP

00000e  0000              DCW      0x0000
                  |L6.16|
                          DCD      0x0001193f

                          AREA ||i.vPortYield||, CODE, READONLY, ALIGN=2

                  vPortYield PROC
;;;364    
;;;365    void vPortYield( void )
000000  f04f5080          MOV      r0,#0x10000000
;;;366    {
;;;367            /* Set a PendSV to request a context switch. */
;;;368            portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
000004  4903              LDR      r1,|L7.20|
000006  6008              STR      r0,[r1,#0]
;;;369    
;;;370            /* Barriers are normally not required but do ensure the code is completely
;;;371            within the specified behaviour for the architecture. */
;;;372            __dsb( portSY_FULL_READ_WRITE );
000008  f3bf8f4f          DSB      
;;;373            __isb( portSY_FULL_READ_WRITE );
00000c  f3bf8f6f          ISB      
;;;374    }
000010  4770              BX       lr
;;;375    /*-----------------------------------------------------------*/
                          ENDP

000012  0000              DCW      0x0000
                  |L7.20|
                          DCD      0xe000ed04

                          AREA ||i.xPortStartScheduler||, CODE, READONLY, ALIGN=2

                  xPortStartScheduler PROC
;;;291     */
;;;292    BaseType_t xPortStartScheduler( void )
000000  b510              PUSH     {r4,lr}
;;;293    {
;;;294    #if( configASSERT_DEFINED == 1 )
;;;295            {
;;;296                    volatile uint32_t ulOriginalPriority;
;;;297                    volatile uint8_t * const pucFirstUserPriorityRegister = ( uint8_t * ) ( portNVIC_IP_REGISTERS_OFFSET_16 + portFIRST_USER_INTERRUPT_NUMBER );
;;;298                    volatile uint8_t ucMaxPriorityValue;
;;;299    
;;;300                    /* Determine the maximum priority from which ISR safe FreeRTOS API
;;;301                    functions can be called.  ISR safe functions are those that end in
;;;302                    "FromISR".  FreeRTOS maintains separate thread and ISR API functions to
;;;303                    ensure interrupt entry is as fast and simple as possible.
;;;304    
;;;305                    Save the interrupt priority value that is about to be clobbered. */
;;;306                    ulOriginalPriority = *pucFirstUserPriorityRegister;
;;;307    
;;;308                    /* Determine the number of priority bits available.  First write to all
;;;309                    possible bits. */
;;;310                    *pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
;;;311    
;;;312                    /* Read the value back to see how many bits stuck. */
;;;313                    ucMaxPriorityValue = *pucFirstUserPriorityRegister;
;;;314    
;;;315                    /* Use the same mask on the maximum system call priority. */
;;;316                    ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
;;;317    
;;;318                    /* Calculate the maximum acceptable priority group value for the number
;;;319                    of bits read back. */
;;;320                    ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
;;;321                    while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
;;;322                    {
;;;323                            ulMaxPRIGROUPValue--;
;;;324                            ucMaxPriorityValue <<= ( uint8_t ) 0x01;
;;;325                    }
;;;326    
;;;327                    /* Shift the priority group value back to its position within the AIRCR
;;;328                    register. */
;;;329                    ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
;;;330                    ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
;;;331    
;;;332                    /* Restore the clobbered interrupt priority register to its original
;;;333                    value. */
;;;334                    *pucFirstUserPriorityRegister = ulOriginalPriority;
;;;335            }
;;;336    #endif /* conifgASSERT_DEFINED */
;;;337    
;;;338            /* Make PendSV and SysTick the lowest priority interrupts. */
;;;339            portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
000002  480a              LDR      r0,|L8.44|
000004  6800              LDR      r0,[r0,#0]
000006  f440007f          ORR      r0,r0,#0xff0000
00000a  4908              LDR      r1,|L8.44|
00000c  6008              STR      r0,[r1,#0]
;;;340            portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
00000e  4608              MOV      r0,r1
000010  6800              LDR      r0,[r0,#0]
000012  f040407f          ORR      r0,r0,#0xff000000
000016  6008              STR      r0,[r1,#0]
;;;341    
;;;342            /* Start the timer that generates the tick ISR.  Interrupts are disabled
;;;343            here already. */
;;;344            vPortSetupTimerInterrupt();
000018  f7fffffe          BL       vPortSetupTimerInterrupt
;;;345    
;;;346            /* Initialise the critical nesting count ready for the first task. */
;;;347            uxCriticalNesting = 0;
00001c  2000              MOVS     r0,#0
00001e  4904              LDR      r1,|L8.48|
000020  6008              STR      r0,[r1,#0]  ; uxCriticalNesting
;;;348    
;;;349            /* Start the first task. */
;;;350            prvStartFirstTask();
000022  f7fffffe          BL       __asm___6_port_c_39a90d8d__prvStartFirstTask
;;;351    
;;;352            /* Should not get here! */
;;;353            return 0;
000026  2000              MOVS     r0,#0
;;;354    }
000028  bd10              POP      {r4,pc}
;;;355    /*-----------------------------------------------------------*/
                          ENDP

00002a  0000              DCW      0x0000
                  |L8.44|
                          DCD      0xe000ed20
                  |L8.48|
                          DCD      uxCriticalNesting

                          AREA ||i.xPortSysTickHandler||, CODE, READONLY, ALIGN=2

                  xPortSysTickHandler PROC
;;;439    
;;;440    void xPortSysTickHandler( void )
000000  b510              PUSH     {r4,lr}
;;;441    {
;;;442            /* The SysTick runs at the lowest interrupt priority, so when this interrupt
;;;443            executes all interrupts must be unmasked.  There is therefore no need to
;;;444            save and then restore the interrupt mask value as its value is already
;;;445            known. */
;;;446            ( void ) portSET_INTERRUPT_MASK_FROM_ISR();
000002  f7fffffe          BL       ulPortSetInterruptMask
;;;447            {
;;;448                    /* Increment the RTOS tick. */
;;;449                    if( xTaskIncrementTick() != pdFALSE ) {
000006  f7fffffe          BL       xTaskIncrementTick
00000a  b118              CBZ      r0,|L9.20|
;;;450                            /* A context switch is required.  Context switching is performed in
;;;451                            the PendSV interrupt.  Pend the PendSV interrupt. */
;;;452                            portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
00000c  f04f5080          MOV      r0,#0x10000000
000010  4902              LDR      r1,|L9.28|
000012  6008              STR      r0,[r1,#0]
                  |L9.20|
;;;453                    }
;;;454            }
;;;455            portCLEAR_INTERRUPT_MASK_FROM_ISR( 0 );
000014  2000              MOVS     r0,#0
000016  f7fffffe          BL       vPortClearInterruptMask
;;;456    }
00001a  bd10              POP      {r4,pc}
;;;457    /*-----------------------------------------------------------*/
                          ENDP

                  |L9.28|
                          DCD      0xe000ed04

                          AREA ||.data||, DATA, ALIGN=2

                  uxCriticalNesting
                          DCD      0xaaaaaaaa

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\FreeRTOS\\Source\\portable\\RVDS\\ARM_CM3\\port.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |vPortSVCHandler|
#line 249
|vPortSVCHandler| PROC
#line 250

 PRESERVE8

 ldr r3, =pxCurrentTCB  
 ldr r1, [r3]  
 ldr r0, [r1]  
 ldmia r0!, {r4-r11}  
 msr psp, r0  
 isb
 mov r0, #0
 msr basepri, r0
 orr r14, #0xd
 bx r14
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___6_port_c_39a90d8d__prvStartFirstTask|
#line 266
|__asm___6_port_c_39a90d8d__prvStartFirstTask| PROC
#line 267

 PRESERVE8

 
 ldr r0, =0xE000ED08
 ldr r0, [r0]
 ldr r0, [r0]

 
 msr msp, r0
 
 cpsie i
 cpsie f
 dsb
 isb
 
 svc 0
 nop
 nop
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |xPortPendSVHandler|
#line 405
|xPortPendSVHandler| PROC
#line 406

 extern uxCriticalNesting
 extern pxCurrentTCB
 extern vTaskSwitchContext

 PRESERVE8

 mrs r0, psp
 isb

 ldr r3, =pxCurrentTCB  
 ldr r2, [r3]

 stmdb r0!, {r4-r11}  
 str r0, [r2]  

 stmdb sp!, {r3, r14}
 mov r0, #191
 msr basepri, r0
 bl vTaskSwitchContext
 mov r0, #0
 msr basepri, r0
 ldmia sp!, {r3, r14}

 ldr r1, [r3]
 ldr r0, [r1]  
 ldmia r0!, {r4-r11}  
 msr psp, r0
 isb
 bx r14
 nop
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |ulPortSetInterruptMask|
#line 627
|ulPortSetInterruptMask| PROC
#line 628

 PRESERVE8

 mrs r0, basepri
 mov r1, #191
 msr basepri, r1
 bx r14
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |vPortClearInterruptMask|
#line 638
|vPortClearInterruptMask| PROC
#line 639

 PRESERVE8

 msr basepri, r0
 bx r14
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |vPortGetIPSR|
#line 647
|vPortGetIPSR| PROC
#line 648

 PRESERVE8

 mrs r0, ipsr
 bx r14
	ENDP

;*** End   embedded assembler ***
